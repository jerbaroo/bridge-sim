<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bridge_sim.sim.model API documentation</title>
<meta name="description" content="Classes for simulation parameters, mesh and simulation responses." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bridge_sim.sim.model</code></h1>
</header>
<section id="section-intro">
<p>Classes for simulation parameters, mesh and simulation responses.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Classes for simulation parameters, mesh and simulation responses.&#34;&#34;&#34;

import itertools
from collections import defaultdict
from typing import Optional, NewType, Dict, List, Tuple, Callable


import dill
import numpy as np
from scipy.interpolate import griddata, interp1d, interp2d
from scipy.spatial import distance

from bridge_sim.model import (
    Support,
    Material,
    Point,
    PointLoad,
    PierSettlement,
    ResponseType,
    Bridge,
    Config,
)
from bridge_sim.util import round_m, safe_str, nearest_index, print_i, print_w, print_d
from bridge_sim.sim.util import _responses_path, poly_area

D = False


class Node:
    &#34;&#34;&#34;A node in a FE model.

    Args:
        n_id: the ID of this node.
        x: x position of this node on the bridge.
        y: y position of this node on the bridge.
        z: z position of this node on the bridge.
        deck: whether this node belongs to the bridge deck.
        pier: a pier that this node may belong to.
        comment: an optional comment for the .tcl file.
        support: a support that this node may belong to.

    Attrs:
        section: Material, a section that may be attached, or not.

    &#34;&#34;&#34;

    def __init__(
        self,
        n_id: int,
        x: float,
        y: float,
        z: float,
        deck: bool,
        pier: Optional[Support] = None,
        comment: Optional[str] = None,
        support: Optional[Support] = None,
    ):
        self.n_id = n_id
        self.x = round_m(x)
        self.y = round_m(y)
        self.z = round_m(z)
        self.pier = pier
        self.deck = deck
        self.comment = comment
        self.support = support

    def command_3d(self):
        &#34;&#34;&#34;OpenSees node command.&#34;&#34;&#34;
        comment = &#34;&#34; if self.comment is None else f&#34;; # {self.comment}&#34;
        return (
            f&#34;node {self.n_id} {round_m(self.x)} {round_m(self.y)}&#34;
            + f&#34; {round_m(self.z)}{comment}&#34;
        )

    def distance(self, x: float, y: float, z: float):
        &#34;&#34;&#34;Distance (with direction) from this node to coordinates.&#34;&#34;&#34;
        return distance.euclidean((self.x, self.y, self.z), (x, y, z))

    def distance_n(self, node):
        &#34;&#34;&#34;Distance (with direction) from this node to another node.&#34;&#34;&#34;
        return self.distance(x=node.x, y=node.y, z=node.z)


NodesById = NewType(&#34;NodesById&#34;, Dict[int, Node])
# Nodes for a bridge deck.
DeckNodes = NewType(&#34;DeckNodes&#34;, List[List[Node]])
# A list of nodes for each shell.
DeckShellNodes = NewType(&#34;DeckShellNodes&#34;, List[Tuple[Node, Node, Node, Node]])
# Nodes for one wall of a pier. Indexed first by z then by x index.
WallNodes = NewType(&#34;WallNodes&#34;, List[List[Node]])
# Nodes for both walls of a single pier.
APierNodes = NewType(&#34;APierNodes&#34;, Tuple[WallNodes, WallNodes])
# Nodes for every pier.
PierNodes = NewType(&#34;PierNodes&#34;, List[APierNodes])
# Deck and pier nodes.
BridgeNodes = NewType(&#34;BridgeNodes&#34;, Tuple[DeckShellNodes, PierNodes])


class Shell:
    &#34;&#34;&#34;A shell element in a FE model.

    NOTE: When this constructor is called additional work is done in setting a
    reference to the given section to all given nodes. Thus associating to each
    given node a section, this information that is attached to nodes is useful
    for creating colored plots of properties of the 3D model.

    Args:
        e_id: index for this shell element.
        ni_id: index of the node at corner i of this shell element.
        nj_id: index of the node at corner j of this shell element.
        nk_id: index of the node at corner k of this shell element.
        nl_id: index of the node at corner l of this shell element.
        section: section that this shell element belongs to.
        pier: whether this shell is on a pier.
        nodes_by_id: nodes in this build context.
        support_position_index: a 4-tuple of the support index, support wall
            index, and z and y indices

    &#34;&#34;&#34;

    def __init__(
        self,
        e_id: int,
        ni_id: int,
        nj_id: int,
        nk_id: int,
        nl_id: int,
        section: Material,
        pier: bool,
        nodes_by_id: NodesById,
        support_position_index: Optional[Tuple[int, int, int, int]] = None,
    ):
        self.e_id = e_id
        self.ni_id = ni_id
        self.nj_id = nj_id
        self.nk_id = nk_id
        self.nl_id = nl_id
        self.pier = pier
        self.section = section
        self.support_position_index = support_position_index
        self.nodes_by_id = nodes_by_id
        self.deck = all(n.y == 0 for n in self.nodes())

        # Attach a reference to the section to each &#39;Node&#39; and note if the node
        # belongs to a pier or to the bridge deck.
        for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
            node = self.nodes_by_id[n_id]
            if pier:
                node.pier_section = self.section
            else:
                node.deck_section = self.section

    def node_ids(self):
        &#34;&#34;&#34;IDs of this element&#39;s nodes.&#34;&#34;&#34;
        return [self.ni_id, self.nj_id, self.nk_id, self.nl_id]

    def nodes(self):
        &#34;&#34;&#34;This element&#39;s nodes.&#34;&#34;&#34;
        return list(map(lambda n_id: self.nodes_by_id[n_id], self.node_ids()))

    def mass(self, config: Config):
        &#34;&#34;&#34;Mass of this shell element: volume x density.&#34;&#34;&#34;
        concrete_mass = self.section.thickness * self.area() * self.section.density
        # Asphalt only considered if Config flag set and is a deck shell.
        if not self.deck or not config.self_weight_asphalt:
            return concrete_mass
        z_min, z_max = self.width(min_max=True)
        assert z_min &lt; z_max
        asphalt_mass = 0
        for lane in config.bridge.lanes:
            if lane.asphalt is None:
                continue
            assert lane.z_min &lt; lane.z_max
            # Shell completely in the lane.
            if z_min &gt;= lane.z_min and z_max &lt;= lane.z_max:
                z_dist = z_max - z_min
            # Shell halfway in the lane.
            elif z_min &lt; lane.z_min &lt;= z_max &lt;= lane.z_max:
                z_dist = z_max - lane.z_min
            # Shell halfway in the lane.
            elif lane.z_min &lt;= z_min &lt;= lane.z_max &lt; z_max:
                z_dist = lane.z_max - z_min
            # Shell spanning the lane.
            elif z_min &lt; lane.z_min and z_max &gt; lane.z_max:
                z_dist = lane.z_max - lane.z_min
            else:
                continue
            z_frac = z_dist / self.width()
            assert 0 &lt;= z_frac &lt;= 1
            asphalt_mass += (
                lane.asphalt.thickness * self.area() * z_frac * lane.asphalt.density
            )
            print_d(
                D,
                f&#34;Concrete density &amp; asphalt density = {self.section.density}, {lane.asphalt.density}&#34;,
            )
        print_d(D, f&#34;Concrete mass &amp; asphalt mass = {concrete_mass}, {asphalt_mass}&#34;)
        return concrete_mass + asphalt_mass

    def area(self):
        &#34;&#34;&#34;Assumes a tetrahedron shape.&#34;&#34;&#34;
        ni = self.nodes_by_id[self.ni_id]
        nj = self.nodes_by_id[self.nj_id]
        nk = self.nodes_by_id[self.nk_id]
        nl = self.nodes_by_id[self.nl_id]

        return poly_area(
            [
                (ni.x, ni.y, ni.z),
                (nj.x, nj.y, nj.z),
                (nk.x, nk.y, nk.z),
                (nl.x, nl.y, nl.z),
            ]
        )

    def center(self) -&gt; Point:
        &#34;&#34;&#34;Point at the center of the element.&#34;&#34;&#34;
        if not hasattr(self, &#34;_center&#34;):
            node_0 = self.nodes_by_id[self.ni_id]
            node_1 = self.nodes_by_id[self.nk_id]
            delta_x = abs(node_0.x - node_1.x)
            delta_y = abs(node_0.y - node_1.y)
            delta_z = abs(node_0.z - node_1.z)
            min_x = min(node_0.x, node_1.x)
            min_y = min(node_0.y, node_1.y)
            min_z = min(node_0.z, node_1.z)
            self._center = Point(
                x=min_x + delta_x / 2, y=min_y + delta_y / 2, z=min_z + delta_z / 2
            )
        return self._center

    def length(self) -&gt; float:
        &#34;&#34;&#34;The length of this element (longitudinal direction).&#34;&#34;&#34;
        if not hasattr(self, &#34;_length&#34;):
            min_x, max_x = np.inf, -np.inf
            for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
                node_x = self.nodes_by_id[n_id].x
                if node_x &lt; min_x:
                    min_x = node_x
                if node_x &gt; max_x:
                    max_x = node_x
            self._length = max_x - min_x
        return self._length

    def width(self, min_max: bool = False) -&gt; float:
        &#34;&#34;&#34;The width of this element (transverse direction).

        Args:
            min_max: instead return a tuple of min and max Z position.

        &#34;&#34;&#34;
        if min_max or not hasattr(self, &#34;_width&#34;):
            min_z, max_z = np.inf, -np.inf
            for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
                node_z = self.nodes_by_id[n_id].z
                if node_z &lt; min_z:
                    min_z = node_z
                if node_z &gt; max_z:
                    max_z = node_z
            if min_max:
                return min_z, max_z
            self._width = max_z - min_z
        return self._width

    def command_3d(self):
        &#34;&#34;&#34;OpenSees element command.&#34;&#34;&#34;
        repr_section = repr(self.section).replace(&#34;\n&#34;, &#34; &#34;)
        return (
            f&#34;element ShellMITC4 {self.e_id} {self.ni_id} {self.nj_id}&#34;
            + f&#34; {self.nk_id} {self.nl_id} {self.section.id}; # {repr_section}&#34;
        )


ShellsById = NewType(&#34;ShellsById&#34;, Dict[int, Shell])
# Shells for a bridge deck.
DeckShells = NewType(&#34;DeckShells&#34;, List[List[Shell]])
# Shells for one wall of a pier. Indexed first by z then by x index.
WallShells = NewType(&#34;WallShells&#34;, List[List[Shell]])
# Shells for both walls of a pier.
APierShells = NewType(&#34;APierShells&#34;, Tuple[WallShells, WallShells])
# Shells for every pier.
PierShells = NewType(&#34;PierShells&#34;, List[APierShells])
# Deck and pier shells.
BridgeShells = NewType(&#34;BridgeShells&#34;, Tuple[DeckShells, PierShells])


class BuildContext:
    &#34;&#34;&#34;Stores nodes and shells for a FEM being built.

    Args:
        add_loads: List[Point], additional grid lines where to add nodes.
        refinement_radii: List[float], radii for sweeps to refine around loads.

    &#34;&#34;&#34;

    def __init__(
        self,
        add_loads: List[Point],
        refinement_radii: List[float] = [],
        # refinement_radii: List[float] = [2, 1, 0.5],
    ):
        self.next_n_id = 1
        self.nodes_by_id: NodesById = dict()
        self.nodes_by_pos = dict()
        # A dict of x to dict of y to dict of z to Node.
        self.nodes_by_pos_dict = defaultdict(lambda: defaultdict(dict))

        self.next_s_id = 1
        self.shells_by_id: ShellsById = dict()
        self.shells_by_n_ids = dict()

        self.add_loads = add_loads
        for point in self.add_loads:
            assert point.y == 0
        self.refinement_radii = refinement_radii

    def new_n_id(self):
        self.next_n_id += 1
        return self.next_n_id - 1

    def new_s_id(self):
        self.next_s_id += 1
        return self.next_s_id - 1

    def get_node(
        self, x: float, y: float, z: float, deck: bool, comment: Optional[str] = None
    ) -&gt; Node:
        x, y, z = round_m(x), round_m(y), round_m(z)
        pos = (x, y, z)
        if pos not in self.nodes_by_pos:
            n_id = self.new_n_id()
            node = Node(n_id=n_id, x=x, y=y, z=z, deck=deck, comment=comment)
            self.nodes_by_id[n_id] = node
            self.nodes_by_pos[pos] = node
            self.nodes_by_pos_dict[x][y][z] = node
        return self.nodes_by_pos[pos]

    def get_shell(
        self,
        ni_id: int,
        nj_id: int,
        nk_id: int,
        nl_id: int,
        pier: bool,
        section: Material,
    ) -&gt; Shell:
        n_ids = (ni_id, nj_id, nk_id, nl_id)
        if n_ids not in self.shells_by_n_ids:
            s_id = self.new_s_id()
            shell = Shell(
                e_id=s_id,
                ni_id=ni_id,
                nj_id=nj_id,
                nk_id=nk_id,
                nl_id=nl_id,
                pier=pier,
                section=section,
                nodes_by_id=self.nodes_by_id,
            )
            self.shells_by_n_ids[n_ids] = shell
            self.shells_by_id[s_id] = shell
        return self.shells_by_n_ids[n_ids]

    def get_nodes_at_xy(self, x: float, y: float):
        x, y = round_m(x), round_m(y)
        return self.nodes_by_pos_dict[x][y].values()


class SimParams:
    &#34;&#34;&#34;Parameters for one FE simulation.

    Args:
        ploads: point loads to apply in the simulation.
        displacement_ctrl:  apply a load until a displacement is reached.
        axial_delta_temp: uniform thermal loading in Celcius.
        moment_delta_temp: linear thermal loading in Celcius.
        self_weight: apply loads corresponding to self-weight in simulation.

    &#34;&#34;&#34;

    def __init__(
        self,
        ploads: List[PointLoad] = [],
        pier_settlement: List[PierSettlement] = [],
        axial_delta_temp: Optional[float] = None,
        moment_delta_temp: Optional[float] = None,
        self_weight: bool = False,
    ):
        self.ploads = ploads
        self.pier_settlement = pier_settlement
        self.axial_delta_temp = axial_delta_temp
        self.moment_delta_temp = moment_delta_temp
        self.self_weight = self_weight

    def build_ctx(self) -&gt; BuildContext:
        &#34;&#34;&#34;Build context from these simulation parameters.

        The build context only requires information on geometry.

        &#34;&#34;&#34;
        return BuildContext(add_loads=[pload.point() for pload in self.ploads])

    def id_str(self, config: Config):
        &#34;&#34;&#34;String representing the simulation parameters.

        NOTE: Response types are not included in the ID string because it is
        currently assumed that a simulation saves all output files.

        &#34;&#34;&#34;
        load_str = &#34;&#34;
        if self.self_weight:
            load_str += &#34;s&#34;
            if config.self_weight_asphalt:
                load_str += &#34;a&#34;
        if self.axial_delta_temp is not None:
            load_str += f&#34;temp-axial-{self.axial_delta_temp}&#34;
        if self.moment_delta_temp is not None:
            load_str += f&#34;temp-moment-{self.moment_delta_temp}&#34;
        if len(self.ploads) &gt; 0:
            pl_str = &#34;,&#34;.join(pl.id_str() for pl in self.ploads)
            load_str += f&#34;[{pl_str}]&#34;
        if len(self.pier_settlement) &gt; 0:
            load_str += &#34;,&#34;.join(ps.id_str() for ps in self.pier_settlement)
        return safe_str(load_str)


class Responses:
    &#34;&#34;&#34;Responses of one sensor type for one FE simulation.&#34;&#34;&#34;

    def __init__(
        self,
        response_type: ResponseType,
        responses: List[&#34;Response&#34;],
        build: bool = True,
        units: Optional[str] = None,
    ):
        assert isinstance(responses, list)
        if len(responses) == 0:
            raise ValueError(&#34;No fem found&#34;)
        assert isinstance(responses[0][1], Point)
        self.response_type = response_type
        self.units = units
        self.raw_responses = responses
        self.num_sensors = len(responses)
        # Nested dictionaries for indexing responses by position.
        self.responses = defaultdict(lambda: defaultdict(lambda: defaultdict(dict)))
        if build:
            for response, p in responses:
                self.responses[0][p.x][p.y][p.z] = response
            self.index()

    def index(self):
        &#34;&#34;&#34;Create attributes for fast indexing of times and positions.&#34;&#34;&#34;
        self.times = sorted(self.responses.keys())
        points = self.responses[self.times[0]]
        self.xs = sorted(points.keys())
        self.ys = {x: sorted(points[x].keys()) for x in self.xs}
        self.deck_xs = [x for x in self.xs if 0 in points[x].keys()]
        self.zs = {
            x: {y: sorted(points[x][y].keys()) for y in self.ys[x]} for x in self.xs
        }

    def deck_points(self) -&gt; List[Point]:
        &#34;&#34;&#34;All the points on the deck where fem are collected.&#34;&#34;&#34;
        return [
            Point(x=x, y=0, z=z)
            for _, (x, y, z) in self.values(point=True)
            if np.isclose(y, 0)
        ]

    def add(self, values: List[float], points: List[Point]):
        &#34;&#34;&#34;Add the values corresponding to given points.

        The points must already be in the fem.

        &#34;&#34;&#34;
        assert len(values) == len(points)
        for v, p in zip(values, points):
            before = self.responses[0][p.x][p.y][p.z]
            self.responses[0][p.x][p.y][p.z] += v
            after = self.responses[0][p.x][p.y][p.z]
            # print(before, after)
        try:
            del self.griddata
        except AttributeError:
            pass
        return self

    def map(self, f, xyz: bool = False):
        &#34;&#34;&#34;Map a function over the response values.&#34;&#34;&#34;
        time = self.times[0]
        for x, y_dict in self.responses[time].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    if xyz:
                        self.responses[time][x][y][z] = f(response, x, y, z)
                    else:
                        self.responses[time][x][y][z] = f(response)
        try:
            del self.griddata
        except AttributeError:
            pass
        return self

    def without(self, remove: Callable[[Point, float], bool]) -&gt; &#34;Responses&#34;:
        responses = []
        for x, y_dict in self.responses[self.times[0]].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    p = Point(x=x, y=y, z=z)
                    if not remove(p, response):
                        responses.append((response, p))
                    # if abs(p.distance(of)) &gt; radius:
        return Responses(
            response_type=self.response_type, responses=responses, units=self.units
        )

    def without_nan_inf(self):
        &#34;&#34;&#34;Copy of these Responses without NaN or INF values.&#34;&#34;&#34;
        return self.without(lambda p, r: np.isnan(r) or np.isinf(r))

    def add_temp_strain(
        self, config: Config, temp_deltas: Tuple[Optional[float], Optional[float]]
    ):
        &#34;&#34;&#34;Convert responses, adding free and restrained strain.&#34;&#34;&#34;
        if not self.response_type.is_strain():
            raise ValueError(f&#34;Can only convert Strain not {self.response_type}&#34;)
        uniform_delta, linear_delta = temp_deltas
        if uniform_delta is not None and linear_delta is not None:
            raise ValueError(&#34;Must be ONLY uniform or linear temperature delta&#34;)
        if uniform_delta is not None:
            subtract = 1 * config.cte * uniform_delta
            print_i(f&#34;Temperature post-processing, subtract strain = {subtract}&#34;)
            return self.map(lambda r: r - subtract)
        if linear_delta is not None:
            add = 0.5 * config.cte * linear_delta
            print_i(f&#34;Temperature post-processing, adding strain = {add}&#34;)
            return self.map(lambda r: r + add)

    def to_stress(self, bridge: Bridge):
        &#34;&#34;&#34;Convert strain responses to stress responses.&#34;&#34;&#34;
        self.response_type = self.response_type.to_stress()
        if len(bridge.sections) == 1:
            youngs = bridge.sections[0].youngs
            self.map(lambda r: r * youngs)
        else:

            def _map(response, x, y, z):
                return response * bridge.deck_section_at(x=x, z=z).youngs

            self.map(_map, xyz=True)
        self.units = None  # We don&#39;t know units since strain is unit-less.
        return self

    def values(self, point: bool = False):
        &#34;&#34;&#34;Yield each response value.&#34;&#34;&#34;
        time = self.times[0]
        for x, y_dict in self.responses[time].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    if point:
                        yield response, (x, y, z)
                    else:
                        yield response

    def at_shells(self, shells: List[&#34;Shell&#34;]) -&gt; &#34;Responses&#34;:
        responses = []
        for shell in shells:
            shell_center = shell.center()
            if shell_center.y != 0:
                raise ValueError(&#34;Can only get response on deck&#34;)
            responses.append((self.at_deck(shell_center, interp=False), shell_center))
        return Responses(response_type=self.response_type, responses=responses,)

    def at_deck(self, point: Point, interp: bool, grid_interp: bool = True):
        &#34;&#34;&#34;Response at the deck (y = 0) with optional interpolation.

        NOTE: Interpolation cannot extrapolate to points outside known data.

        &#34;&#34;&#34;
        assert point.y == 0
        if not interp:
            return self._at_deck_snap(x=point.x, z=point.z)
        return self._at_deck_interp(x=point.x, z=point.z, grid_interp=grid_interp)

    def at_decks(self, points: List[Point]) -&gt; List[float]:
        &#34;&#34;&#34;Like &#39;at_deck&#39; with grid interpolation, but more efficient for many points.

        NOTE: Interpolation cannot extrapolate to points outside known data.

        &#34;&#34;&#34;
        self._at_deck_interp(0, 0)  # Ensure the grid of points is calculated.
        xzs = np.array([[point.x, point.z] for point in points])
        points, values = self.griddata
        return griddata(points, values, xzs)
        # result = self.grid_interp2d(xzs[0].flatten(), xzs[1].flatten())[0]
        # return result

    def _at_deck_interp(self, x: float, z: float, grid_interp=True):
        # Assign to new variables, so they are not overwritten in loop.
        _x, _z = x, z
        # Determine grid of point and values for interpolation.
        if not hasattr(self, &#34;griddata&#34;):
            points = []
            values = []
            # For each x on the deck..
            for x in self.deck_xs:
                # for each z, for that x, determine value.
                for z in self.zs[x][0]:
                    points.append([x, z])
                    values.append(self.responses[0][x][0][z])
            self.griddata = np.array(points), np.array(values)
            # points = self.griddata[0].T
            # self.grid_interp2d = interp2d(points[0], points[1], values)
        # If grid interpolation selected then perform it.
        if grid_interp:
            points, values = self.griddata
            result = griddata(points, values, [[_x, _z]])[0]
            # result = self.grid_interp2d([_x], [_z])[0]
            # print(f&#34;x = {_x}, z = {_z}, result = {result}&#34;)
            return result

    def _at_deck_snap(self, x: float, z: float):
        &#34;&#34;&#34;Deck response from nearest available sensor.&#34;&#34;&#34;
        y = 0
        x_ind = nearest_index(self.deck_xs, x)
        x_near = self.deck_xs[x_ind]
        z_ind = nearest_index(self.zs[x_near][y], z)
        z_near = self.zs[x_near][y][z_ind]
        return self.responses[0][x_near][y][z_near]


class SimResponses(Responses):
    &#34;&#34;&#34;Responses of one sensor type for one FE simulation.&#34;&#34;&#34;

    def __init__(
        self,
        c: Config,
        sim_params: SimParams,
        sim_runner: &#34;FEMRunner&#34;,
        response_type: ResponseType,
        responses: List[&#34;Response&#34;],
        build: bool = True,
    ):
        self.c = c
        self.sim_params = sim_params
        self.sim_runner = sim_runner
        super().__init__(response_type=response_type, responses=responses, build=build)

    def save(self):
        &#34;&#34;&#34;Save theses simulation fem to disk.&#34;&#34;&#34;
        path = _responses_path(
            config=self.c,
            sim_runner=self.sim_runner,
            sim_params=self.sim_params,
            response_type=self.response_type,
        )
        try:
            with open(path, &#34;wb&#34;) as f:
                dill.dump(self.raw_responses, f)
        except:
            print(&#34;Could not save raw responses&#34;, flush=True)


def bridge_3d_nodes(deck_nodes: DeckNodes, all_support_nodes: PierNodes) -&gt; List[Node]:
    &#34;&#34;&#34;All a bridge&#39;s nodes in a deterministic order.&#34;&#34;&#34;
    all_nodes = list(itertools.chain.from_iterable(deck_nodes))
    for support_nodes in all_support_nodes:
        for wall_nodes in support_nodes:
            for y_nodes in wall_nodes:
                for node in y_nodes:
                    all_nodes.append(node)
    assert isinstance(all_nodes[0], Node)
    assert isinstance(all_nodes[-1], Node)
    print_i(f&#34;Total bridge nodes: {len(all_nodes)}&#34;)
    return all_nodes


def bridge_3d_elements(
    deck_elements: DeckShells, all_pier_elements: PierShells
) -&gt; List[Shell]:
    &#34;&#34;&#34;All a bridge&#39;s shell elements in a deterministic order.&#34;&#34;&#34;
    all_elements = list(itertools.chain.from_iterable(deck_elements))
    for pier_element in all_pier_elements:
        all_elements.append(pier_element)
    assert isinstance(all_elements[0], Shell)
    assert isinstance(all_elements[-1], Shell)
    return all_elements</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bridge_sim.sim.model.bridge_3d_elements"><code class="name flex">
<span>def <span class="ident">bridge_3d_elements</span></span>(<span>deck_elements: <function NewType.<locals>.new_type at 0x119445940>, all_pier_elements: <function NewType.<locals>.new_type at 0x119445af0>) -> List[<a title="bridge_sim.sim.model.Shell" href="#bridge_sim.sim.model.Shell">Shell</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>All a bridge's shell elements in a deterministic order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bridge_3d_elements(
    deck_elements: DeckShells, all_pier_elements: PierShells
) -&gt; List[Shell]:
    &#34;&#34;&#34;All a bridge&#39;s shell elements in a deterministic order.&#34;&#34;&#34;
    all_elements = list(itertools.chain.from_iterable(deck_elements))
    for pier_element in all_pier_elements:
        all_elements.append(pier_element)
    assert isinstance(all_elements[0], Shell)
    assert isinstance(all_elements[-1], Shell)
    return all_elements</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.bridge_3d_nodes"><code class="name flex">
<span>def <span class="ident">bridge_3d_nodes</span></span>(<span>deck_nodes: <function NewType.<locals>.new_type at 0x119445040>, all_support_nodes: <function NewType.<locals>.new_type at 0x119445280>) -> List[<a title="bridge_sim.sim.model.Node" href="#bridge_sim.sim.model.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>All a bridge's nodes in a deterministic order.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bridge_3d_nodes(deck_nodes: DeckNodes, all_support_nodes: PierNodes) -&gt; List[Node]:
    &#34;&#34;&#34;All a bridge&#39;s nodes in a deterministic order.&#34;&#34;&#34;
    all_nodes = list(itertools.chain.from_iterable(deck_nodes))
    for support_nodes in all_support_nodes:
        for wall_nodes in support_nodes:
            for y_nodes in wall_nodes:
                for node in y_nodes:
                    all_nodes.append(node)
    assert isinstance(all_nodes[0], Node)
    assert isinstance(all_nodes[-1], Node)
    print_i(f&#34;Total bridge nodes: {len(all_nodes)}&#34;)
    return all_nodes</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="bridge_sim.sim.model.BuildContext"><code class="flex name class">
<span>class <span class="ident">BuildContext</span></span>
<span>(</span><span>add_loads: List[<a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a>], refinement_radii: List[float] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Stores nodes and shells for a FEM being built.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>add_loads</code></strong></dt>
<dd>List[Point], additional grid lines where to add nodes.</dd>
<dt><strong><code>refinement_radii</code></strong></dt>
<dd>List[float], radii for sweeps to refine around loads.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BuildContext:
    &#34;&#34;&#34;Stores nodes and shells for a FEM being built.

    Args:
        add_loads: List[Point], additional grid lines where to add nodes.
        refinement_radii: List[float], radii for sweeps to refine around loads.

    &#34;&#34;&#34;

    def __init__(
        self,
        add_loads: List[Point],
        refinement_radii: List[float] = [],
        # refinement_radii: List[float] = [2, 1, 0.5],
    ):
        self.next_n_id = 1
        self.nodes_by_id: NodesById = dict()
        self.nodes_by_pos = dict()
        # A dict of x to dict of y to dict of z to Node.
        self.nodes_by_pos_dict = defaultdict(lambda: defaultdict(dict))

        self.next_s_id = 1
        self.shells_by_id: ShellsById = dict()
        self.shells_by_n_ids = dict()

        self.add_loads = add_loads
        for point in self.add_loads:
            assert point.y == 0
        self.refinement_radii = refinement_radii

    def new_n_id(self):
        self.next_n_id += 1
        return self.next_n_id - 1

    def new_s_id(self):
        self.next_s_id += 1
        return self.next_s_id - 1

    def get_node(
        self, x: float, y: float, z: float, deck: bool, comment: Optional[str] = None
    ) -&gt; Node:
        x, y, z = round_m(x), round_m(y), round_m(z)
        pos = (x, y, z)
        if pos not in self.nodes_by_pos:
            n_id = self.new_n_id()
            node = Node(n_id=n_id, x=x, y=y, z=z, deck=deck, comment=comment)
            self.nodes_by_id[n_id] = node
            self.nodes_by_pos[pos] = node
            self.nodes_by_pos_dict[x][y][z] = node
        return self.nodes_by_pos[pos]

    def get_shell(
        self,
        ni_id: int,
        nj_id: int,
        nk_id: int,
        nl_id: int,
        pier: bool,
        section: Material,
    ) -&gt; Shell:
        n_ids = (ni_id, nj_id, nk_id, nl_id)
        if n_ids not in self.shells_by_n_ids:
            s_id = self.new_s_id()
            shell = Shell(
                e_id=s_id,
                ni_id=ni_id,
                nj_id=nj_id,
                nk_id=nk_id,
                nl_id=nl_id,
                pier=pier,
                section=section,
                nodes_by_id=self.nodes_by_id,
            )
            self.shells_by_n_ids[n_ids] = shell
            self.shells_by_id[s_id] = shell
        return self.shells_by_n_ids[n_ids]

    def get_nodes_at_xy(self, x: float, y: float):
        x, y = round_m(x), round_m(y)
        return self.nodes_by_pos_dict[x][y].values()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.BuildContext.get_node"><code class="name flex">
<span>def <span class="ident">get_node</span></span>(<span>self, x: float, y: float, z: float, deck: bool, comment: Union[str, NoneType] = None) -> <a title="bridge_sim.sim.model.Node" href="#bridge_sim.sim.model.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node(
    self, x: float, y: float, z: float, deck: bool, comment: Optional[str] = None
) -&gt; Node:
    x, y, z = round_m(x), round_m(y), round_m(z)
    pos = (x, y, z)
    if pos not in self.nodes_by_pos:
        n_id = self.new_n_id()
        node = Node(n_id=n_id, x=x, y=y, z=z, deck=deck, comment=comment)
        self.nodes_by_id[n_id] = node
        self.nodes_by_pos[pos] = node
        self.nodes_by_pos_dict[x][y][z] = node
    return self.nodes_by_pos[pos]</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.BuildContext.get_nodes_at_xy"><code class="name flex">
<span>def <span class="ident">get_nodes_at_xy</span></span>(<span>self, x: float, y: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes_at_xy(self, x: float, y: float):
    x, y = round_m(x), round_m(y)
    return self.nodes_by_pos_dict[x][y].values()</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.BuildContext.get_shell"><code class="name flex">
<span>def <span class="ident">get_shell</span></span>(<span>self, ni_id: int, nj_id: int, nk_id: int, nl_id: int, pier: bool, section: <a title="bridge_sim.model.Material" href="../../model/index.html#bridge_sim.model.Material">Material</a>) -> <a title="bridge_sim.sim.model.Shell" href="#bridge_sim.sim.model.Shell">Shell</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_shell(
    self,
    ni_id: int,
    nj_id: int,
    nk_id: int,
    nl_id: int,
    pier: bool,
    section: Material,
) -&gt; Shell:
    n_ids = (ni_id, nj_id, nk_id, nl_id)
    if n_ids not in self.shells_by_n_ids:
        s_id = self.new_s_id()
        shell = Shell(
            e_id=s_id,
            ni_id=ni_id,
            nj_id=nj_id,
            nk_id=nk_id,
            nl_id=nl_id,
            pier=pier,
            section=section,
            nodes_by_id=self.nodes_by_id,
        )
        self.shells_by_n_ids[n_ids] = shell
        self.shells_by_id[s_id] = shell
    return self.shells_by_n_ids[n_ids]</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.BuildContext.new_n_id"><code class="name flex">
<span>def <span class="ident">new_n_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_n_id(self):
    self.next_n_id += 1
    return self.next_n_id - 1</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.BuildContext.new_s_id"><code class="name flex">
<span>def <span class="ident">new_s_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_s_id(self):
    self.next_s_id += 1
    return self.next_s_id - 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bridge_sim.sim.model.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>n_id: int, x: float, y: float, z: float, deck: bool, pier: Union[bridge_sim.model.Support, NoneType] = None, comment: Union[str, NoneType] = None, support: Union[bridge_sim.model.Support, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A node in a FE model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>n_id</code></strong></dt>
<dd>the ID of this node.</dd>
<dt><strong><code>x</code></strong></dt>
<dd>x position of this node on the bridge.</dd>
<dt><strong><code>y</code></strong></dt>
<dd>y position of this node on the bridge.</dd>
<dt><strong><code>z</code></strong></dt>
<dd>z position of this node on the bridge.</dd>
<dt><strong><code>deck</code></strong></dt>
<dd>whether this node belongs to the bridge deck.</dd>
<dt><strong><code>pier</code></strong></dt>
<dd>a pier that this node may belong to.</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>an optional comment for the .tcl file.</dd>
<dt><strong><code>support</code></strong></dt>
<dd>a support that this node may belong to.</dd>
</dl>
<h2 id="attrs">Attrs</h2>
<p>section: Material, a section that may be attached, or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;A node in a FE model.

    Args:
        n_id: the ID of this node.
        x: x position of this node on the bridge.
        y: y position of this node on the bridge.
        z: z position of this node on the bridge.
        deck: whether this node belongs to the bridge deck.
        pier: a pier that this node may belong to.
        comment: an optional comment for the .tcl file.
        support: a support that this node may belong to.

    Attrs:
        section: Material, a section that may be attached, or not.

    &#34;&#34;&#34;

    def __init__(
        self,
        n_id: int,
        x: float,
        y: float,
        z: float,
        deck: bool,
        pier: Optional[Support] = None,
        comment: Optional[str] = None,
        support: Optional[Support] = None,
    ):
        self.n_id = n_id
        self.x = round_m(x)
        self.y = round_m(y)
        self.z = round_m(z)
        self.pier = pier
        self.deck = deck
        self.comment = comment
        self.support = support

    def command_3d(self):
        &#34;&#34;&#34;OpenSees node command.&#34;&#34;&#34;
        comment = &#34;&#34; if self.comment is None else f&#34;; # {self.comment}&#34;
        return (
            f&#34;node {self.n_id} {round_m(self.x)} {round_m(self.y)}&#34;
            + f&#34; {round_m(self.z)}{comment}&#34;
        )

    def distance(self, x: float, y: float, z: float):
        &#34;&#34;&#34;Distance (with direction) from this node to coordinates.&#34;&#34;&#34;
        return distance.euclidean((self.x, self.y, self.z), (x, y, z))

    def distance_n(self, node):
        &#34;&#34;&#34;Distance (with direction) from this node to another node.&#34;&#34;&#34;
        return self.distance(x=node.x, y=node.y, z=node.z)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.Node.command_3d"><code class="name flex">
<span>def <span class="ident">command_3d</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>OpenSees node command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_3d(self):
    &#34;&#34;&#34;OpenSees node command.&#34;&#34;&#34;
    comment = &#34;&#34; if self.comment is None else f&#34;; # {self.comment}&#34;
    return (
        f&#34;node {self.n_id} {round_m(self.x)} {round_m(self.y)}&#34;
        + f&#34; {round_m(self.z)}{comment}&#34;
    )</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Node.distance"><code class="name flex">
<span>def <span class="ident">distance</span></span>(<span>self, x: float, y: float, z: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Distance (with direction) from this node to coordinates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance(self, x: float, y: float, z: float):
    &#34;&#34;&#34;Distance (with direction) from this node to coordinates.&#34;&#34;&#34;
    return distance.euclidean((self.x, self.y, self.z), (x, y, z))</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Node.distance_n"><code class="name flex">
<span>def <span class="ident">distance_n</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Distance (with direction) from this node to another node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_n(self, node):
    &#34;&#34;&#34;Distance (with direction) from this node to another node.&#34;&#34;&#34;
    return self.distance(x=node.x, y=node.y, z=node.z)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bridge_sim.sim.model.Responses"><code class="flex name class">
<span>class <span class="ident">Responses</span></span>
<span>(</span><span>response_type: <a title="bridge_sim.model.ResponseType" href="../../model/index.html#bridge_sim.model.ResponseType">ResponseType</a>, responses: List[ForwardRef('Response')], build: bool = True, units: Union[str, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Responses of one sensor type for one FE simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Responses:
    &#34;&#34;&#34;Responses of one sensor type for one FE simulation.&#34;&#34;&#34;

    def __init__(
        self,
        response_type: ResponseType,
        responses: List[&#34;Response&#34;],
        build: bool = True,
        units: Optional[str] = None,
    ):
        assert isinstance(responses, list)
        if len(responses) == 0:
            raise ValueError(&#34;No fem found&#34;)
        assert isinstance(responses[0][1], Point)
        self.response_type = response_type
        self.units = units
        self.raw_responses = responses
        self.num_sensors = len(responses)
        # Nested dictionaries for indexing responses by position.
        self.responses = defaultdict(lambda: defaultdict(lambda: defaultdict(dict)))
        if build:
            for response, p in responses:
                self.responses[0][p.x][p.y][p.z] = response
            self.index()

    def index(self):
        &#34;&#34;&#34;Create attributes for fast indexing of times and positions.&#34;&#34;&#34;
        self.times = sorted(self.responses.keys())
        points = self.responses[self.times[0]]
        self.xs = sorted(points.keys())
        self.ys = {x: sorted(points[x].keys()) for x in self.xs}
        self.deck_xs = [x for x in self.xs if 0 in points[x].keys()]
        self.zs = {
            x: {y: sorted(points[x][y].keys()) for y in self.ys[x]} for x in self.xs
        }

    def deck_points(self) -&gt; List[Point]:
        &#34;&#34;&#34;All the points on the deck where fem are collected.&#34;&#34;&#34;
        return [
            Point(x=x, y=0, z=z)
            for _, (x, y, z) in self.values(point=True)
            if np.isclose(y, 0)
        ]

    def add(self, values: List[float], points: List[Point]):
        &#34;&#34;&#34;Add the values corresponding to given points.

        The points must already be in the fem.

        &#34;&#34;&#34;
        assert len(values) == len(points)
        for v, p in zip(values, points):
            before = self.responses[0][p.x][p.y][p.z]
            self.responses[0][p.x][p.y][p.z] += v
            after = self.responses[0][p.x][p.y][p.z]
            # print(before, after)
        try:
            del self.griddata
        except AttributeError:
            pass
        return self

    def map(self, f, xyz: bool = False):
        &#34;&#34;&#34;Map a function over the response values.&#34;&#34;&#34;
        time = self.times[0]
        for x, y_dict in self.responses[time].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    if xyz:
                        self.responses[time][x][y][z] = f(response, x, y, z)
                    else:
                        self.responses[time][x][y][z] = f(response)
        try:
            del self.griddata
        except AttributeError:
            pass
        return self

    def without(self, remove: Callable[[Point, float], bool]) -&gt; &#34;Responses&#34;:
        responses = []
        for x, y_dict in self.responses[self.times[0]].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    p = Point(x=x, y=y, z=z)
                    if not remove(p, response):
                        responses.append((response, p))
                    # if abs(p.distance(of)) &gt; radius:
        return Responses(
            response_type=self.response_type, responses=responses, units=self.units
        )

    def without_nan_inf(self):
        &#34;&#34;&#34;Copy of these Responses without NaN or INF values.&#34;&#34;&#34;
        return self.without(lambda p, r: np.isnan(r) or np.isinf(r))

    def add_temp_strain(
        self, config: Config, temp_deltas: Tuple[Optional[float], Optional[float]]
    ):
        &#34;&#34;&#34;Convert responses, adding free and restrained strain.&#34;&#34;&#34;
        if not self.response_type.is_strain():
            raise ValueError(f&#34;Can only convert Strain not {self.response_type}&#34;)
        uniform_delta, linear_delta = temp_deltas
        if uniform_delta is not None and linear_delta is not None:
            raise ValueError(&#34;Must be ONLY uniform or linear temperature delta&#34;)
        if uniform_delta is not None:
            subtract = 1 * config.cte * uniform_delta
            print_i(f&#34;Temperature post-processing, subtract strain = {subtract}&#34;)
            return self.map(lambda r: r - subtract)
        if linear_delta is not None:
            add = 0.5 * config.cte * linear_delta
            print_i(f&#34;Temperature post-processing, adding strain = {add}&#34;)
            return self.map(lambda r: r + add)

    def to_stress(self, bridge: Bridge):
        &#34;&#34;&#34;Convert strain responses to stress responses.&#34;&#34;&#34;
        self.response_type = self.response_type.to_stress()
        if len(bridge.sections) == 1:
            youngs = bridge.sections[0].youngs
            self.map(lambda r: r * youngs)
        else:

            def _map(response, x, y, z):
                return response * bridge.deck_section_at(x=x, z=z).youngs

            self.map(_map, xyz=True)
        self.units = None  # We don&#39;t know units since strain is unit-less.
        return self

    def values(self, point: bool = False):
        &#34;&#34;&#34;Yield each response value.&#34;&#34;&#34;
        time = self.times[0]
        for x, y_dict in self.responses[time].items():
            for y, z_dict in y_dict.items():
                for z, response in z_dict.items():
                    if point:
                        yield response, (x, y, z)
                    else:
                        yield response

    def at_shells(self, shells: List[&#34;Shell&#34;]) -&gt; &#34;Responses&#34;:
        responses = []
        for shell in shells:
            shell_center = shell.center()
            if shell_center.y != 0:
                raise ValueError(&#34;Can only get response on deck&#34;)
            responses.append((self.at_deck(shell_center, interp=False), shell_center))
        return Responses(response_type=self.response_type, responses=responses,)

    def at_deck(self, point: Point, interp: bool, grid_interp: bool = True):
        &#34;&#34;&#34;Response at the deck (y = 0) with optional interpolation.

        NOTE: Interpolation cannot extrapolate to points outside known data.

        &#34;&#34;&#34;
        assert point.y == 0
        if not interp:
            return self._at_deck_snap(x=point.x, z=point.z)
        return self._at_deck_interp(x=point.x, z=point.z, grid_interp=grid_interp)

    def at_decks(self, points: List[Point]) -&gt; List[float]:
        &#34;&#34;&#34;Like &#39;at_deck&#39; with grid interpolation, but more efficient for many points.

        NOTE: Interpolation cannot extrapolate to points outside known data.

        &#34;&#34;&#34;
        self._at_deck_interp(0, 0)  # Ensure the grid of points is calculated.
        xzs = np.array([[point.x, point.z] for point in points])
        points, values = self.griddata
        return griddata(points, values, xzs)
        # result = self.grid_interp2d(xzs[0].flatten(), xzs[1].flatten())[0]
        # return result

    def _at_deck_interp(self, x: float, z: float, grid_interp=True):
        # Assign to new variables, so they are not overwritten in loop.
        _x, _z = x, z
        # Determine grid of point and values for interpolation.
        if not hasattr(self, &#34;griddata&#34;):
            points = []
            values = []
            # For each x on the deck..
            for x in self.deck_xs:
                # for each z, for that x, determine value.
                for z in self.zs[x][0]:
                    points.append([x, z])
                    values.append(self.responses[0][x][0][z])
            self.griddata = np.array(points), np.array(values)
            # points = self.griddata[0].T
            # self.grid_interp2d = interp2d(points[0], points[1], values)
        # If grid interpolation selected then perform it.
        if grid_interp:
            points, values = self.griddata
            result = griddata(points, values, [[_x, _z]])[0]
            # result = self.grid_interp2d([_x], [_z])[0]
            # print(f&#34;x = {_x}, z = {_z}, result = {result}&#34;)
            return result

    def _at_deck_snap(self, x: float, z: float):
        &#34;&#34;&#34;Deck response from nearest available sensor.&#34;&#34;&#34;
        y = 0
        x_ind = nearest_index(self.deck_xs, x)
        x_near = self.deck_xs[x_ind]
        z_ind = nearest_index(self.zs[x_near][y], z)
        z_near = self.zs[x_near][y][z_ind]
        return self.responses[0][x_near][y][z_near]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="bridge_sim.sim.model.SimResponses" href="#bridge_sim.sim.model.SimResponses">SimResponses</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.Responses.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, values: List[float], points: List[<a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Add the values corresponding to given points.</p>
<p>The points must already be in the fem.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, values: List[float], points: List[Point]):
    &#34;&#34;&#34;Add the values corresponding to given points.

    The points must already be in the fem.

    &#34;&#34;&#34;
    assert len(values) == len(points)
    for v, p in zip(values, points):
        before = self.responses[0][p.x][p.y][p.z]
        self.responses[0][p.x][p.y][p.z] += v
        after = self.responses[0][p.x][p.y][p.z]
        # print(before, after)
    try:
        del self.griddata
    except AttributeError:
        pass
    return self</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.add_temp_strain"><code class="name flex">
<span>def <span class="ident">add_temp_strain</span></span>(<span>self, config: <a title="bridge_sim.model.Config" href="../../model/index.html#bridge_sim.model.Config">Config</a>, temp_deltas: Tuple[Union[float, NoneType], Union[float, NoneType]])</span>
</code></dt>
<dd>
<div class="desc"><p>Convert responses, adding free and restrained strain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_temp_strain(
    self, config: Config, temp_deltas: Tuple[Optional[float], Optional[float]]
):
    &#34;&#34;&#34;Convert responses, adding free and restrained strain.&#34;&#34;&#34;
    if not self.response_type.is_strain():
        raise ValueError(f&#34;Can only convert Strain not {self.response_type}&#34;)
    uniform_delta, linear_delta = temp_deltas
    if uniform_delta is not None and linear_delta is not None:
        raise ValueError(&#34;Must be ONLY uniform or linear temperature delta&#34;)
    if uniform_delta is not None:
        subtract = 1 * config.cte * uniform_delta
        print_i(f&#34;Temperature post-processing, subtract strain = {subtract}&#34;)
        return self.map(lambda r: r - subtract)
    if linear_delta is not None:
        add = 0.5 * config.cte * linear_delta
        print_i(f&#34;Temperature post-processing, adding strain = {add}&#34;)
        return self.map(lambda r: r + add)</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.at_deck"><code class="name flex">
<span>def <span class="ident">at_deck</span></span>(<span>self, point: <a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a>, interp: bool, grid_interp: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Response at the deck (y = 0) with optional interpolation.</p>
<p>NOTE: Interpolation cannot extrapolate to points outside known data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_deck(self, point: Point, interp: bool, grid_interp: bool = True):
    &#34;&#34;&#34;Response at the deck (y = 0) with optional interpolation.

    NOTE: Interpolation cannot extrapolate to points outside known data.

    &#34;&#34;&#34;
    assert point.y == 0
    if not interp:
        return self._at_deck_snap(x=point.x, z=point.z)
    return self._at_deck_interp(x=point.x, z=point.z, grid_interp=grid_interp)</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.at_decks"><code class="name flex">
<span>def <span class="ident">at_decks</span></span>(<span>self, points: List[<a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a>]) -> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>Like 'at_deck' with grid interpolation, but more efficient for many points.</p>
<p>NOTE: Interpolation cannot extrapolate to points outside known data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_decks(self, points: List[Point]) -&gt; List[float]:
    &#34;&#34;&#34;Like &#39;at_deck&#39; with grid interpolation, but more efficient for many points.

    NOTE: Interpolation cannot extrapolate to points outside known data.

    &#34;&#34;&#34;
    self._at_deck_interp(0, 0)  # Ensure the grid of points is calculated.
    xzs = np.array([[point.x, point.z] for point in points])
    points, values = self.griddata
    return griddata(points, values, xzs)</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.at_shells"><code class="name flex">
<span>def <span class="ident">at_shells</span></span>(<span>self, shells: List[ForwardRef('<a title="bridge_sim.sim.model.Shell" href="#bridge_sim.sim.model.Shell">Shell</a>')]) -> <a title="bridge_sim.sim.model.Responses" href="#bridge_sim.sim.model.Responses">Responses</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at_shells(self, shells: List[&#34;Shell&#34;]) -&gt; &#34;Responses&#34;:
    responses = []
    for shell in shells:
        shell_center = shell.center()
        if shell_center.y != 0:
            raise ValueError(&#34;Can only get response on deck&#34;)
        responses.append((self.at_deck(shell_center, interp=False), shell_center))
    return Responses(response_type=self.response_type, responses=responses,)</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.deck_points"><code class="name flex">
<span>def <span class="ident">deck_points</span></span>(<span>self) -> List[<a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>All the points on the deck where fem are collected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deck_points(self) -&gt; List[Point]:
    &#34;&#34;&#34;All the points on the deck where fem are collected.&#34;&#34;&#34;
    return [
        Point(x=x, y=0, z=z)
        for _, (x, y, z) in self.values(point=True)
        if np.isclose(y, 0)
    ]</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create attributes for fast indexing of times and positions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self):
    &#34;&#34;&#34;Create attributes for fast indexing of times and positions.&#34;&#34;&#34;
    self.times = sorted(self.responses.keys())
    points = self.responses[self.times[0]]
    self.xs = sorted(points.keys())
    self.ys = {x: sorted(points[x].keys()) for x in self.xs}
    self.deck_xs = [x for x in self.xs if 0 in points[x].keys()]
    self.zs = {
        x: {y: sorted(points[x][y].keys()) for y in self.ys[x]} for x in self.xs
    }</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, f, xyz: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Map a function over the response values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, f, xyz: bool = False):
    &#34;&#34;&#34;Map a function over the response values.&#34;&#34;&#34;
    time = self.times[0]
    for x, y_dict in self.responses[time].items():
        for y, z_dict in y_dict.items():
            for z, response in z_dict.items():
                if xyz:
                    self.responses[time][x][y][z] = f(response, x, y, z)
                else:
                    self.responses[time][x][y][z] = f(response)
    try:
        del self.griddata
    except AttributeError:
        pass
    return self</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.to_stress"><code class="name flex">
<span>def <span class="ident">to_stress</span></span>(<span>self, bridge: <a title="bridge_sim.model.Bridge" href="../../model/index.html#bridge_sim.model.Bridge">Bridge</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert strain responses to stress responses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_stress(self, bridge: Bridge):
    &#34;&#34;&#34;Convert strain responses to stress responses.&#34;&#34;&#34;
    self.response_type = self.response_type.to_stress()
    if len(bridge.sections) == 1:
        youngs = bridge.sections[0].youngs
        self.map(lambda r: r * youngs)
    else:

        def _map(response, x, y, z):
            return response * bridge.deck_section_at(x=x, z=z).youngs

        self.map(_map, xyz=True)
    self.units = None  # We don&#39;t know units since strain is unit-less.
    return self</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self, point: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield each response value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self, point: bool = False):
    &#34;&#34;&#34;Yield each response value.&#34;&#34;&#34;
    time = self.times[0]
    for x, y_dict in self.responses[time].items():
        for y, z_dict in y_dict.items():
            for z, response in z_dict.items():
                if point:
                    yield response, (x, y, z)
                else:
                    yield response</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.without"><code class="name flex">
<span>def <span class="ident">without</span></span>(<span>self, remove: Callable[[bridge_sim.model.Point, float], bool]) -> <a title="bridge_sim.sim.model.Responses" href="#bridge_sim.sim.model.Responses">Responses</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without(self, remove: Callable[[Point, float], bool]) -&gt; &#34;Responses&#34;:
    responses = []
    for x, y_dict in self.responses[self.times[0]].items():
        for y, z_dict in y_dict.items():
            for z, response in z_dict.items():
                p = Point(x=x, y=y, z=z)
                if not remove(p, response):
                    responses.append((response, p))
                # if abs(p.distance(of)) &gt; radius:
    return Responses(
        response_type=self.response_type, responses=responses, units=self.units
    )</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Responses.without_nan_inf"><code class="name flex">
<span>def <span class="ident">without_nan_inf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy of these Responses without NaN or INF values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without_nan_inf(self):
    &#34;&#34;&#34;Copy of these Responses without NaN or INF values.&#34;&#34;&#34;
    return self.without(lambda p, r: np.isnan(r) or np.isinf(r))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bridge_sim.sim.model.Shell"><code class="flex name class">
<span>class <span class="ident">Shell</span></span>
<span>(</span><span>e_id: int, ni_id: int, nj_id: int, nk_id: int, nl_id: int, section: <a title="bridge_sim.model.Material" href="../../model/index.html#bridge_sim.model.Material">Material</a>, pier: bool, nodes_by_id: <function NewType.<locals>.new_type at 0x1193c7700>, support_position_index: Union[Tuple[int, int, int, int], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A shell element in a FE model.</p>
<p>NOTE: When this constructor is called additional work is done in setting a
reference to the given section to all given nodes. Thus associating to each
given node a section, this information that is attached to nodes is useful
for creating colored plots of properties of the 3D model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>e_id</code></strong></dt>
<dd>index for this shell element.</dd>
<dt><strong><code>ni_id</code></strong></dt>
<dd>index of the node at corner i of this shell element.</dd>
<dt><strong><code>nj_id</code></strong></dt>
<dd>index of the node at corner j of this shell element.</dd>
<dt><strong><code>nk_id</code></strong></dt>
<dd>index of the node at corner k of this shell element.</dd>
<dt><strong><code>nl_id</code></strong></dt>
<dd>index of the node at corner l of this shell element.</dd>
<dt><strong><code>section</code></strong></dt>
<dd>section that this shell element belongs to.</dd>
<dt><strong><code>pier</code></strong></dt>
<dd>whether this shell is on a pier.</dd>
<dt><strong><code>nodes_by_id</code></strong></dt>
<dd>nodes in this build context.</dd>
<dt><strong><code>support_position_index</code></strong></dt>
<dd>a 4-tuple of the support index, support wall
index, and z and y indices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shell:
    &#34;&#34;&#34;A shell element in a FE model.

    NOTE: When this constructor is called additional work is done in setting a
    reference to the given section to all given nodes. Thus associating to each
    given node a section, this information that is attached to nodes is useful
    for creating colored plots of properties of the 3D model.

    Args:
        e_id: index for this shell element.
        ni_id: index of the node at corner i of this shell element.
        nj_id: index of the node at corner j of this shell element.
        nk_id: index of the node at corner k of this shell element.
        nl_id: index of the node at corner l of this shell element.
        section: section that this shell element belongs to.
        pier: whether this shell is on a pier.
        nodes_by_id: nodes in this build context.
        support_position_index: a 4-tuple of the support index, support wall
            index, and z and y indices

    &#34;&#34;&#34;

    def __init__(
        self,
        e_id: int,
        ni_id: int,
        nj_id: int,
        nk_id: int,
        nl_id: int,
        section: Material,
        pier: bool,
        nodes_by_id: NodesById,
        support_position_index: Optional[Tuple[int, int, int, int]] = None,
    ):
        self.e_id = e_id
        self.ni_id = ni_id
        self.nj_id = nj_id
        self.nk_id = nk_id
        self.nl_id = nl_id
        self.pier = pier
        self.section = section
        self.support_position_index = support_position_index
        self.nodes_by_id = nodes_by_id
        self.deck = all(n.y == 0 for n in self.nodes())

        # Attach a reference to the section to each &#39;Node&#39; and note if the node
        # belongs to a pier or to the bridge deck.
        for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
            node = self.nodes_by_id[n_id]
            if pier:
                node.pier_section = self.section
            else:
                node.deck_section = self.section

    def node_ids(self):
        &#34;&#34;&#34;IDs of this element&#39;s nodes.&#34;&#34;&#34;
        return [self.ni_id, self.nj_id, self.nk_id, self.nl_id]

    def nodes(self):
        &#34;&#34;&#34;This element&#39;s nodes.&#34;&#34;&#34;
        return list(map(lambda n_id: self.nodes_by_id[n_id], self.node_ids()))

    def mass(self, config: Config):
        &#34;&#34;&#34;Mass of this shell element: volume x density.&#34;&#34;&#34;
        concrete_mass = self.section.thickness * self.area() * self.section.density
        # Asphalt only considered if Config flag set and is a deck shell.
        if not self.deck or not config.self_weight_asphalt:
            return concrete_mass
        z_min, z_max = self.width(min_max=True)
        assert z_min &lt; z_max
        asphalt_mass = 0
        for lane in config.bridge.lanes:
            if lane.asphalt is None:
                continue
            assert lane.z_min &lt; lane.z_max
            # Shell completely in the lane.
            if z_min &gt;= lane.z_min and z_max &lt;= lane.z_max:
                z_dist = z_max - z_min
            # Shell halfway in the lane.
            elif z_min &lt; lane.z_min &lt;= z_max &lt;= lane.z_max:
                z_dist = z_max - lane.z_min
            # Shell halfway in the lane.
            elif lane.z_min &lt;= z_min &lt;= lane.z_max &lt; z_max:
                z_dist = lane.z_max - z_min
            # Shell spanning the lane.
            elif z_min &lt; lane.z_min and z_max &gt; lane.z_max:
                z_dist = lane.z_max - lane.z_min
            else:
                continue
            z_frac = z_dist / self.width()
            assert 0 &lt;= z_frac &lt;= 1
            asphalt_mass += (
                lane.asphalt.thickness * self.area() * z_frac * lane.asphalt.density
            )
            print_d(
                D,
                f&#34;Concrete density &amp; asphalt density = {self.section.density}, {lane.asphalt.density}&#34;,
            )
        print_d(D, f&#34;Concrete mass &amp; asphalt mass = {concrete_mass}, {asphalt_mass}&#34;)
        return concrete_mass + asphalt_mass

    def area(self):
        &#34;&#34;&#34;Assumes a tetrahedron shape.&#34;&#34;&#34;
        ni = self.nodes_by_id[self.ni_id]
        nj = self.nodes_by_id[self.nj_id]
        nk = self.nodes_by_id[self.nk_id]
        nl = self.nodes_by_id[self.nl_id]

        return poly_area(
            [
                (ni.x, ni.y, ni.z),
                (nj.x, nj.y, nj.z),
                (nk.x, nk.y, nk.z),
                (nl.x, nl.y, nl.z),
            ]
        )

    def center(self) -&gt; Point:
        &#34;&#34;&#34;Point at the center of the element.&#34;&#34;&#34;
        if not hasattr(self, &#34;_center&#34;):
            node_0 = self.nodes_by_id[self.ni_id]
            node_1 = self.nodes_by_id[self.nk_id]
            delta_x = abs(node_0.x - node_1.x)
            delta_y = abs(node_0.y - node_1.y)
            delta_z = abs(node_0.z - node_1.z)
            min_x = min(node_0.x, node_1.x)
            min_y = min(node_0.y, node_1.y)
            min_z = min(node_0.z, node_1.z)
            self._center = Point(
                x=min_x + delta_x / 2, y=min_y + delta_y / 2, z=min_z + delta_z / 2
            )
        return self._center

    def length(self) -&gt; float:
        &#34;&#34;&#34;The length of this element (longitudinal direction).&#34;&#34;&#34;
        if not hasattr(self, &#34;_length&#34;):
            min_x, max_x = np.inf, -np.inf
            for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
                node_x = self.nodes_by_id[n_id].x
                if node_x &lt; min_x:
                    min_x = node_x
                if node_x &gt; max_x:
                    max_x = node_x
            self._length = max_x - min_x
        return self._length

    def width(self, min_max: bool = False) -&gt; float:
        &#34;&#34;&#34;The width of this element (transverse direction).

        Args:
            min_max: instead return a tuple of min and max Z position.

        &#34;&#34;&#34;
        if min_max or not hasattr(self, &#34;_width&#34;):
            min_z, max_z = np.inf, -np.inf
            for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
                node_z = self.nodes_by_id[n_id].z
                if node_z &lt; min_z:
                    min_z = node_z
                if node_z &gt; max_z:
                    max_z = node_z
            if min_max:
                return min_z, max_z
            self._width = max_z - min_z
        return self._width

    def command_3d(self):
        &#34;&#34;&#34;OpenSees element command.&#34;&#34;&#34;
        repr_section = repr(self.section).replace(&#34;\n&#34;, &#34; &#34;)
        return (
            f&#34;element ShellMITC4 {self.e_id} {self.ni_id} {self.nj_id}&#34;
            + f&#34; {self.nk_id} {self.nl_id} {self.section.id}; # {repr_section}&#34;
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.Shell.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Assumes a tetrahedron shape.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Assumes a tetrahedron shape.&#34;&#34;&#34;
    ni = self.nodes_by_id[self.ni_id]
    nj = self.nodes_by_id[self.nj_id]
    nk = self.nodes_by_id[self.nk_id]
    nl = self.nodes_by_id[self.nl_id]

    return poly_area(
        [
            (ni.x, ni.y, ni.z),
            (nj.x, nj.y, nj.z),
            (nk.x, nk.y, nk.z),
            (nl.x, nl.y, nl.z),
        ]
    )</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self) -> <a title="bridge_sim.model.Point" href="../../model/index.html#bridge_sim.model.Point">Point</a></span>
</code></dt>
<dd>
<div class="desc"><p>Point at the center of the element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center(self) -&gt; Point:
    &#34;&#34;&#34;Point at the center of the element.&#34;&#34;&#34;
    if not hasattr(self, &#34;_center&#34;):
        node_0 = self.nodes_by_id[self.ni_id]
        node_1 = self.nodes_by_id[self.nk_id]
        delta_x = abs(node_0.x - node_1.x)
        delta_y = abs(node_0.y - node_1.y)
        delta_z = abs(node_0.z - node_1.z)
        min_x = min(node_0.x, node_1.x)
        min_y = min(node_0.y, node_1.y)
        min_z = min(node_0.z, node_1.z)
        self._center = Point(
            x=min_x + delta_x / 2, y=min_y + delta_y / 2, z=min_z + delta_z / 2
        )
    return self._center</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.command_3d"><code class="name flex">
<span>def <span class="ident">command_3d</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>OpenSees element command.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_3d(self):
    &#34;&#34;&#34;OpenSees element command.&#34;&#34;&#34;
    repr_section = repr(self.section).replace(&#34;\n&#34;, &#34; &#34;)
    return (
        f&#34;element ShellMITC4 {self.e_id} {self.ni_id} {self.nj_id}&#34;
        + f&#34; {self.nk_id} {self.nl_id} {self.section.id}; # {repr_section}&#34;
    )</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.length"><code class="name flex">
<span>def <span class="ident">length</span></span>(<span>self) -> float</span>
</code></dt>
<dd>
<div class="desc"><p>The length of this element (longitudinal direction).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def length(self) -&gt; float:
    &#34;&#34;&#34;The length of this element (longitudinal direction).&#34;&#34;&#34;
    if not hasattr(self, &#34;_length&#34;):
        min_x, max_x = np.inf, -np.inf
        for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
            node_x = self.nodes_by_id[n_id].x
            if node_x &lt; min_x:
                min_x = node_x
            if node_x &gt; max_x:
                max_x = node_x
        self._length = max_x - min_x
    return self._length</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.mass"><code class="name flex">
<span>def <span class="ident">mass</span></span>(<span>self, config: <a title="bridge_sim.model.Config" href="../../model/index.html#bridge_sim.model.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mass of this shell element: volume x density.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass(self, config: Config):
    &#34;&#34;&#34;Mass of this shell element: volume x density.&#34;&#34;&#34;
    concrete_mass = self.section.thickness * self.area() * self.section.density
    # Asphalt only considered if Config flag set and is a deck shell.
    if not self.deck or not config.self_weight_asphalt:
        return concrete_mass
    z_min, z_max = self.width(min_max=True)
    assert z_min &lt; z_max
    asphalt_mass = 0
    for lane in config.bridge.lanes:
        if lane.asphalt is None:
            continue
        assert lane.z_min &lt; lane.z_max
        # Shell completely in the lane.
        if z_min &gt;= lane.z_min and z_max &lt;= lane.z_max:
            z_dist = z_max - z_min
        # Shell halfway in the lane.
        elif z_min &lt; lane.z_min &lt;= z_max &lt;= lane.z_max:
            z_dist = z_max - lane.z_min
        # Shell halfway in the lane.
        elif lane.z_min &lt;= z_min &lt;= lane.z_max &lt; z_max:
            z_dist = lane.z_max - z_min
        # Shell spanning the lane.
        elif z_min &lt; lane.z_min and z_max &gt; lane.z_max:
            z_dist = lane.z_max - lane.z_min
        else:
            continue
        z_frac = z_dist / self.width()
        assert 0 &lt;= z_frac &lt;= 1
        asphalt_mass += (
            lane.asphalt.thickness * self.area() * z_frac * lane.asphalt.density
        )
        print_d(
            D,
            f&#34;Concrete density &amp; asphalt density = {self.section.density}, {lane.asphalt.density}&#34;,
        )
    print_d(D, f&#34;Concrete mass &amp; asphalt mass = {concrete_mass}, {asphalt_mass}&#34;)
    return concrete_mass + asphalt_mass</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.node_ids"><code class="name flex">
<span>def <span class="ident">node_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>IDs of this element's nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_ids(self):
    &#34;&#34;&#34;IDs of this element&#39;s nodes.&#34;&#34;&#34;
    return [self.ni_id, self.nj_id, self.nk_id, self.nl_id]</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.nodes"><code class="name flex">
<span>def <span class="ident">nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This element's nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nodes(self):
    &#34;&#34;&#34;This element&#39;s nodes.&#34;&#34;&#34;
    return list(map(lambda n_id: self.nodes_by_id[n_id], self.node_ids()))</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.Shell.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self, min_max: bool = False) -> float</span>
</code></dt>
<dd>
<div class="desc"><p>The width of this element (transverse direction).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min_max</code></strong></dt>
<dd>instead return a tuple of min and max Z position.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def width(self, min_max: bool = False) -&gt; float:
    &#34;&#34;&#34;The width of this element (transverse direction).

    Args:
        min_max: instead return a tuple of min and max Z position.

    &#34;&#34;&#34;
    if min_max or not hasattr(self, &#34;_width&#34;):
        min_z, max_z = np.inf, -np.inf
        for n_id in [self.ni_id, self.nj_id, self.nk_id, self.nl_id]:
            node_z = self.nodes_by_id[n_id].z
            if node_z &lt; min_z:
                min_z = node_z
            if node_z &gt; max_z:
                max_z = node_z
        if min_max:
            return min_z, max_z
        self._width = max_z - min_z
    return self._width</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bridge_sim.sim.model.SimParams"><code class="flex name class">
<span>class <span class="ident">SimParams</span></span>
<span>(</span><span>ploads: List[<a title="bridge_sim.model.PointLoad" href="../../model/index.html#bridge_sim.model.PointLoad">PointLoad</a>] = [], pier_settlement: List[<a title="bridge_sim.model.PierSettlement" href="../../model/index.html#bridge_sim.model.PierSettlement">PierSettlement</a>] = [], axial_delta_temp: Union[float, NoneType] = None, moment_delta_temp: Union[float, NoneType] = None, self_weight: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parameters for one FE simulation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ploads</code></strong></dt>
<dd>point loads to apply in the simulation.</dd>
<dt><strong><code>displacement_ctrl</code></strong></dt>
<dd>apply a load until a displacement is reached.</dd>
<dt><strong><code>axial_delta_temp</code></strong></dt>
<dd>uniform thermal loading in Celcius.</dd>
<dt><strong><code>moment_delta_temp</code></strong></dt>
<dd>linear thermal loading in Celcius.</dd>
<dt><strong><code>self_weight</code></strong></dt>
<dd>apply loads corresponding to self-weight in simulation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimParams:
    &#34;&#34;&#34;Parameters for one FE simulation.

    Args:
        ploads: point loads to apply in the simulation.
        displacement_ctrl:  apply a load until a displacement is reached.
        axial_delta_temp: uniform thermal loading in Celcius.
        moment_delta_temp: linear thermal loading in Celcius.
        self_weight: apply loads corresponding to self-weight in simulation.

    &#34;&#34;&#34;

    def __init__(
        self,
        ploads: List[PointLoad] = [],
        pier_settlement: List[PierSettlement] = [],
        axial_delta_temp: Optional[float] = None,
        moment_delta_temp: Optional[float] = None,
        self_weight: bool = False,
    ):
        self.ploads = ploads
        self.pier_settlement = pier_settlement
        self.axial_delta_temp = axial_delta_temp
        self.moment_delta_temp = moment_delta_temp
        self.self_weight = self_weight

    def build_ctx(self) -&gt; BuildContext:
        &#34;&#34;&#34;Build context from these simulation parameters.

        The build context only requires information on geometry.

        &#34;&#34;&#34;
        return BuildContext(add_loads=[pload.point() for pload in self.ploads])

    def id_str(self, config: Config):
        &#34;&#34;&#34;String representing the simulation parameters.

        NOTE: Response types are not included in the ID string because it is
        currently assumed that a simulation saves all output files.

        &#34;&#34;&#34;
        load_str = &#34;&#34;
        if self.self_weight:
            load_str += &#34;s&#34;
            if config.self_weight_asphalt:
                load_str += &#34;a&#34;
        if self.axial_delta_temp is not None:
            load_str += f&#34;temp-axial-{self.axial_delta_temp}&#34;
        if self.moment_delta_temp is not None:
            load_str += f&#34;temp-moment-{self.moment_delta_temp}&#34;
        if len(self.ploads) &gt; 0:
            pl_str = &#34;,&#34;.join(pl.id_str() for pl in self.ploads)
            load_str += f&#34;[{pl_str}]&#34;
        if len(self.pier_settlement) &gt; 0:
            load_str += &#34;,&#34;.join(ps.id_str() for ps in self.pier_settlement)
        return safe_str(load_str)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.SimParams.build_ctx"><code class="name flex">
<span>def <span class="ident">build_ctx</span></span>(<span>self) -> <a title="bridge_sim.sim.model.BuildContext" href="#bridge_sim.sim.model.BuildContext">BuildContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Build context from these simulation parameters.</p>
<p>The build context only requires information on geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_ctx(self) -&gt; BuildContext:
    &#34;&#34;&#34;Build context from these simulation parameters.

    The build context only requires information on geometry.

    &#34;&#34;&#34;
    return BuildContext(add_loads=[pload.point() for pload in self.ploads])</code></pre>
</details>
</dd>
<dt id="bridge_sim.sim.model.SimParams.id_str"><code class="name flex">
<span>def <span class="ident">id_str</span></span>(<span>self, config: <a title="bridge_sim.model.Config" href="../../model/index.html#bridge_sim.model.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>String representing the simulation parameters.</p>
<p>NOTE: Response types are not included in the ID string because it is
currently assumed that a simulation saves all output files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def id_str(self, config: Config):
    &#34;&#34;&#34;String representing the simulation parameters.

    NOTE: Response types are not included in the ID string because it is
    currently assumed that a simulation saves all output files.

    &#34;&#34;&#34;
    load_str = &#34;&#34;
    if self.self_weight:
        load_str += &#34;s&#34;
        if config.self_weight_asphalt:
            load_str += &#34;a&#34;
    if self.axial_delta_temp is not None:
        load_str += f&#34;temp-axial-{self.axial_delta_temp}&#34;
    if self.moment_delta_temp is not None:
        load_str += f&#34;temp-moment-{self.moment_delta_temp}&#34;
    if len(self.ploads) &gt; 0:
        pl_str = &#34;,&#34;.join(pl.id_str() for pl in self.ploads)
        load_str += f&#34;[{pl_str}]&#34;
    if len(self.pier_settlement) &gt; 0:
        load_str += &#34;,&#34;.join(ps.id_str() for ps in self.pier_settlement)
    return safe_str(load_str)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="bridge_sim.sim.model.SimResponses"><code class="flex name class">
<span>class <span class="ident">SimResponses</span></span>
<span>(</span><span>c: <a title="bridge_sim.model.Config" href="../../model/index.html#bridge_sim.model.Config">Config</a>, sim_params: <a title="bridge_sim.sim.model.SimParams" href="#bridge_sim.sim.model.SimParams">SimParams</a>, sim_runner: FEMRunner, response_type: <a title="bridge_sim.model.ResponseType" href="../../model/index.html#bridge_sim.model.ResponseType">ResponseType</a>, responses: List[ForwardRef('Response')], build: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Responses of one sensor type for one FE simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SimResponses(Responses):
    &#34;&#34;&#34;Responses of one sensor type for one FE simulation.&#34;&#34;&#34;

    def __init__(
        self,
        c: Config,
        sim_params: SimParams,
        sim_runner: &#34;FEMRunner&#34;,
        response_type: ResponseType,
        responses: List[&#34;Response&#34;],
        build: bool = True,
    ):
        self.c = c
        self.sim_params = sim_params
        self.sim_runner = sim_runner
        super().__init__(response_type=response_type, responses=responses, build=build)

    def save(self):
        &#34;&#34;&#34;Save theses simulation fem to disk.&#34;&#34;&#34;
        path = _responses_path(
            config=self.c,
            sim_runner=self.sim_runner,
            sim_params=self.sim_params,
            response_type=self.response_type,
        )
        try:
            with open(path, &#34;wb&#34;) as f:
                dill.dump(self.raw_responses, f)
        except:
            print(&#34;Could not save raw responses&#34;, flush=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="bridge_sim.sim.model.Responses" href="#bridge_sim.sim.model.Responses">Responses</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="bridge_sim.sim.model.SimResponses.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save theses simulation fem to disk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self):
    &#34;&#34;&#34;Save theses simulation fem to disk.&#34;&#34;&#34;
    path = _responses_path(
        config=self.c,
        sim_runner=self.sim_runner,
        sim_params=self.sim_params,
        response_type=self.response_type,
    )
    try:
        with open(path, &#34;wb&#34;) as f:
            dill.dump(self.raw_responses, f)
    except:
        print(&#34;Could not save raw responses&#34;, flush=True)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="bridge_sim.sim.model.Responses" href="#bridge_sim.sim.model.Responses">Responses</a></b></code>:
<ul class="hlist">
<li><code><a title="bridge_sim.sim.model.Responses.add" href="#bridge_sim.sim.model.Responses.add">add</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.add_temp_strain" href="#bridge_sim.sim.model.Responses.add_temp_strain">add_temp_strain</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.at_deck" href="#bridge_sim.sim.model.Responses.at_deck">at_deck</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.at_decks" href="#bridge_sim.sim.model.Responses.at_decks">at_decks</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.deck_points" href="#bridge_sim.sim.model.Responses.deck_points">deck_points</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.index" href="#bridge_sim.sim.model.Responses.index">index</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.map" href="#bridge_sim.sim.model.Responses.map">map</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.to_stress" href="#bridge_sim.sim.model.Responses.to_stress">to_stress</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.values" href="#bridge_sim.sim.model.Responses.values">values</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.without_nan_inf" href="#bridge_sim.sim.model.Responses.without_nan_inf">without_nan_inf</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bridge_sim.sim" href="../index.html">bridge_sim.sim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bridge_sim.sim.model.bridge_3d_elements" href="#bridge_sim.sim.model.bridge_3d_elements">bridge_3d_elements</a></code></li>
<li><code><a title="bridge_sim.sim.model.bridge_3d_nodes" href="#bridge_sim.sim.model.bridge_3d_nodes">bridge_3d_nodes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="bridge_sim.sim.model.BuildContext" href="#bridge_sim.sim.model.BuildContext">BuildContext</a></code></h4>
<ul class="">
<li><code><a title="bridge_sim.sim.model.BuildContext.get_node" href="#bridge_sim.sim.model.BuildContext.get_node">get_node</a></code></li>
<li><code><a title="bridge_sim.sim.model.BuildContext.get_nodes_at_xy" href="#bridge_sim.sim.model.BuildContext.get_nodes_at_xy">get_nodes_at_xy</a></code></li>
<li><code><a title="bridge_sim.sim.model.BuildContext.get_shell" href="#bridge_sim.sim.model.BuildContext.get_shell">get_shell</a></code></li>
<li><code><a title="bridge_sim.sim.model.BuildContext.new_n_id" href="#bridge_sim.sim.model.BuildContext.new_n_id">new_n_id</a></code></li>
<li><code><a title="bridge_sim.sim.model.BuildContext.new_s_id" href="#bridge_sim.sim.model.BuildContext.new_s_id">new_s_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bridge_sim.sim.model.Node" href="#bridge_sim.sim.model.Node">Node</a></code></h4>
<ul class="">
<li><code><a title="bridge_sim.sim.model.Node.command_3d" href="#bridge_sim.sim.model.Node.command_3d">command_3d</a></code></li>
<li><code><a title="bridge_sim.sim.model.Node.distance" href="#bridge_sim.sim.model.Node.distance">distance</a></code></li>
<li><code><a title="bridge_sim.sim.model.Node.distance_n" href="#bridge_sim.sim.model.Node.distance_n">distance_n</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bridge_sim.sim.model.Responses" href="#bridge_sim.sim.model.Responses">Responses</a></code></h4>
<ul class="two-column">
<li><code><a title="bridge_sim.sim.model.Responses.add" href="#bridge_sim.sim.model.Responses.add">add</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.add_temp_strain" href="#bridge_sim.sim.model.Responses.add_temp_strain">add_temp_strain</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.at_deck" href="#bridge_sim.sim.model.Responses.at_deck">at_deck</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.at_decks" href="#bridge_sim.sim.model.Responses.at_decks">at_decks</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.at_shells" href="#bridge_sim.sim.model.Responses.at_shells">at_shells</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.deck_points" href="#bridge_sim.sim.model.Responses.deck_points">deck_points</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.index" href="#bridge_sim.sim.model.Responses.index">index</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.map" href="#bridge_sim.sim.model.Responses.map">map</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.to_stress" href="#bridge_sim.sim.model.Responses.to_stress">to_stress</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.values" href="#bridge_sim.sim.model.Responses.values">values</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.without" href="#bridge_sim.sim.model.Responses.without">without</a></code></li>
<li><code><a title="bridge_sim.sim.model.Responses.without_nan_inf" href="#bridge_sim.sim.model.Responses.without_nan_inf">without_nan_inf</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bridge_sim.sim.model.Shell" href="#bridge_sim.sim.model.Shell">Shell</a></code></h4>
<ul class="two-column">
<li><code><a title="bridge_sim.sim.model.Shell.area" href="#bridge_sim.sim.model.Shell.area">area</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.center" href="#bridge_sim.sim.model.Shell.center">center</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.command_3d" href="#bridge_sim.sim.model.Shell.command_3d">command_3d</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.length" href="#bridge_sim.sim.model.Shell.length">length</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.mass" href="#bridge_sim.sim.model.Shell.mass">mass</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.node_ids" href="#bridge_sim.sim.model.Shell.node_ids">node_ids</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.nodes" href="#bridge_sim.sim.model.Shell.nodes">nodes</a></code></li>
<li><code><a title="bridge_sim.sim.model.Shell.width" href="#bridge_sim.sim.model.Shell.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bridge_sim.sim.model.SimParams" href="#bridge_sim.sim.model.SimParams">SimParams</a></code></h4>
<ul class="">
<li><code><a title="bridge_sim.sim.model.SimParams.build_ctx" href="#bridge_sim.sim.model.SimParams.build_ctx">build_ctx</a></code></li>
<li><code><a title="bridge_sim.sim.model.SimParams.id_str" href="#bridge_sim.sim.model.SimParams.id_str">id_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="bridge_sim.sim.model.SimResponses" href="#bridge_sim.sim.model.SimResponses">SimResponses</a></code></h4>
<ul class="">
<li><code><a title="bridge_sim.sim.model.SimResponses.save" href="#bridge_sim.sim.model.SimResponses.save">save</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>