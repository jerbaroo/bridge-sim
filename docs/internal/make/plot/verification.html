<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>bridge_sim.internal.make.plot.verification API documentation</title>
<meta name="description" content="Verification plots." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bridge_sim.internal.make.plot.verification</code></h1>
</header>
<section id="section-intro">
<p>Verification plots.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Verification plots.&#34;&#34;&#34;

import glob
import itertools
import os
from collections import defaultdict
from copy import deepcopy
from datetime import datetime
from timeit import default_timer as timer
from typing import List, Optional, Tuple

import matplotlib
import matplotlib.cm as cm
import numpy as np
import pandas as pd
from scipy.interpolate import interp1d
from sklearn.linear_model import LinearRegression

from bridge_sim.internal.plot import plt
from bridge_sim.model import Config, PierSettlement, Point, PointLoad, ResponseType
from bridge_sim.sim.responses import to_vehicles_direct
from bridge_sim.vehicles import truck1
from bridge_sim.sim.build import det_nodes, det_shells
from bridge_sim.sim.model import SimParams
from bridge_sim.sim.responses import load_fem_responses
from bridge_sim.sim.run.opensees import OSRunner
from bridge_sim.plot.util import legend_marker_size
from bridge_sim.plot import contour_responses, top_view_bridge
from bridge_sim.internal.plot.validation import (
    plot_mmm_strain_convergence,
    plot_nesw_convergence,
)
from bridge_sim.util import (
    print_i,
    print_w,
    round_m,
    safe_str,
    scalar,
)
from bridge_sim.internal.validate import (
    _meas,
    _displa_sensors,
    _strain_sensors,
    _strain_sensor_xz,
    _displa_sensor_xz,
)

# Positions of truck front axle.
truck_front_x = np.arange(1, 116.1, 1)

diana_path = &#34;data/validation/modelpredictions_april2019.csv&#34;
if os.path.exists(diana_path):
    diana = pd.read_csv(diana_path)

# Interpolation function for each sensor position.
diana_interp_funcs = dict()


def diana_response(sensor_label: str, truck_x: float):
    &#34;&#34;&#34;Strain or displacement from Diana for a sensor and truck position.&#34;&#34;&#34;
    if sensor_label not in diana_interp_funcs:
        all_sensors = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        diana_interp_funcs[sensor_label] = interp1d(
            all_sensors[&#34;xpostruck&#34;], all_sensors[&#34;infline1&#34;]
        )
    return diana_interp_funcs[sensor_label](truck_x)


def per_sensor_plots(
    c: Config,
    rows: int = 3,
    strain_sensors_startwith: str = &#34;T&#34;,
    strain_sensors_ignore: List[str] = [&#34;T0&#34;],
    individual_sensors: List[str] = [&#34;T4&#34;, &#34;U3&#34;],
    plot_diana: bool = False,
):
    &#34;&#34;&#34;Compare the bridge 705 measurement campaign to Diana and OpenSees.&#34;&#34;&#34;
    plt.portrait()
    size = 80  # Size of scatter plot points.
    lw = 4  # Line width of plots.

    ##########
    # Strain #
    ##########

    print_i(&#34;All strain sensors = &#34;)
    print_i(f&#34;  {sorted(set(_meas[&#39;sensorlabel&#39;]))}&#34;)
    # All strain measurements for a given sensor set (strain_sensors_startwith),
    # except ignore sensors in ignore set (strain_sensors_ignore).
    tno_strain_meas = _meas.loc[
        _meas[&#34;sensorlabel&#34;].str.startswith(strain_sensors_startwith)
    ]
    labels_before_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    tno_strain_meas = tno_strain_meas.loc[
        ~tno_strain_meas[&#34;sensorlabel&#34;].isin(strain_sensors_ignore)
    ]
    labels_after_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    labels_ignored = sorted(
        l for l in labels_before_ignore if l not in labels_after_ignore
    )
    print_i(f&#34;Strain sensors ignored = {labels_ignored}&#34;)

    # Ignore sensors with missing positions.
    positions_available = set(
        _strain_sensors[_strain_sensors[&#34;direction&#34;] == &#34;X&#34;][&#34;label&#34;]
    )
    labels_before_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    tno_strain_meas = tno_strain_meas.loc[
        tno_strain_meas[&#34;sensorlabel&#34;].isin(positions_available)
    ]
    labels_after_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    labels_ignored = sorted(
        l for l in labels_before_ignore if l not in labels_after_ignore
    )
    print_i(f&#34;Microstrain XXB sensors with missing positions = {labels_ignored}&#34;)

    # Sort by sensor number and setup groupby sensor label.
    tno_strain_meas[&#34;sort&#34;] = tno_strain_meas[&#34;sensorlabel&#34;].apply(lambda x: int(x[1:]))
    print_i(f&#34;Filtered strain sensors starting with {strain_sensors_startwith} =&#34;)
    print_i(f&#34;  {sorted(set(map(int, tno_strain_meas[&#39;sort&#39;])))}&#34;)

    tno_strain_meas = tno_strain_meas.sort_values(by=[&#34;sort&#34;])
    strain_groupby = tno_strain_meas.groupby(&#34;sensorlabel&#34;, sort=False)
    strain_sensor_labels = [sensor_label for sensor_label, _ in strain_groupby]
    strain_sensor_xzs = list(map(_strain_sensor_xz, strain_sensor_labels))
    print(f&#34;strain sensor xsz = {strain_sensor_xzs}&#34;)

    # Find the min and max fem.
    amin, amax = np.inf, -np.inf
    for sensor_label, meas_group in strain_groupby:
        diana_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        responses = (
            diana_group[&#34;infline1&#34;].to_list() + meas_group[&#34;inflinedata&#34;].to_list()
        )
        amin = min(amin, np.amin(responses))
        amax = max(amax, np.amax(responses))
    amin *= 1.1
    amax *= 1.1

    # Calculate displacement with OpenSees via direct simulation.
    print(f&#34;Parallel {c.parallel}&#34;)
    os_strain = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_front_x],
            response_type=ResponseType.StrainXXB,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z)
                for sensor_x, sensor_z in strain_sensor_xzs
            ],
        ).T
        * 1e6
    )
    os_strain_shape = np.array(os_strain).shape
    if len(os_strain_shape) == 3 and os_strain_shape[0] == 1:
        os_strain = os_strain[0]
    amin = min(amin, np.amin(os_strain))
    amax = max(amax, np.amax(os_strain))

    def plot(i, sensor_label, meas_group):
        # Plot Diana predictions for the given sensor.
        if plot_diana:
            diana_sensor_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
            plt.plot(
                diana_sensor_group[&#34;xpostruck&#34;],
                diana_sensor_group[&#34;infline1&#34;],
                lw=lw,
                label=&#34;Diana&#34;,
            )

        # Plot values from OpenSees.
        plt.plot(truck_front_x, os_strain[i], lw=lw, label=&#34;OpenSees&#34;, c=&#34;tab:blue&#34;)

        # Plot measured values against truck position.
        sensor_x, sensor_z = strain_sensor_xzs[i]
        plt.scatter(
            meas_group[&#34;xpostruck&#34;],
            meas_group[&#34;inflinedata&#34;],
            marker=&#34;o&#34;,
            s=size,
            label=&#34;Measurement&#34;,
            zorder=3,
            color=&#34;tab:red&#34;,
        )

        plt.scatter(
            [0],
            [0],
            label=f&#34;{sensor_label}: x = {np.around(sensor_x, 3)} m, z = {np.around(sensor_z, 3)} m&#34;,
            alpha=0,
            zorder=4,
        )
        legend_marker_size(plt.legend(), 80)
        plt.ylabel(&#34;Microstrain XXB&#34;)
        plt.ylim((amin, amax))

    # Create a subplot for each strain sensor.
    plot_i, subplot_i = 0, 0
    for i, (sensor_label, meas_group) in enumerate(strain_groupby):
        plt.subplot(rows, 1, subplot_i + 1)
        plot(i, sensor_label, meas_group)
        if (subplot_i == rows - 1) or i == len(strain_groupby) - 1:
            plt.xlabel(&#34;X position of Truck 1&#39;s front axle (m)&#34;)
            plt.suptitle(
                &#34;Microstrain XXB from Truck 1 on bridge 705\nstatic simulation vs. static test&#34;
            )
            plt.tight_layout(rect=[0, 0.03, 1, 0.93])
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;,
                    f&#34;strain-{strain_sensors_startwith}-{plot_i}.pdf&#34;,
                )
            )
            plt.close()
            subplot_i = 0
            plot_i += 1
        else:
            plt.tick_params(axis=&#34;x&#34;, bottom=False, labelbottom=False)
            subplot_i += 1

    # Create any plots for individual strain sensors.
    for i, (sensor_label, meas_group) in enumerate(strain_groupby):
        if sensor_label in individual_sensors:
            plt.landscape()
            plot(i, sensor_label, meas_group)
            plt.tight_layout()
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;, f&#34;strain-sensor-{sensor_label}.pdf&#34;
                )
            )
            plt.close()
            plt.portrait()

    ################
    # Vert. trans. #
    ################

    # All displacement measurements.
    displa_meas = pd.DataFrame(_meas.loc[_meas[&#34;sensortype&#34;] == &#34;displacements&#34;])

    # Sort by sensor number and setup groupby sensor label.
    displa_meas[&#34;sort&#34;] = displa_meas[&#34;sensorlabel&#34;].apply(lambda x: int(x[1:]))
    displa_meas = displa_meas.sort_values(by=[&#34;sort&#34;])
    displa_groupby = displa_meas.groupby(&#34;sensorlabel&#34;, sort=False)
    displa_sensor_labels = [sensor_label for sensor_label, _ in displa_groupby]
    displa_sensor_xzs = list(map(_displa_sensor_xz, displa_sensor_labels))

    # Find the min and max fem.
    amin, amax = np.inf, -np.inf
    for sensor_label, meas_group in displa_groupby:
        diana_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        responses = (
            diana_group[&#34;infline1&#34;].to_list() + meas_group[&#34;inflinedata&#34;].to_list()
        )
        amin = min(amin, np.amin(responses))
        amax = max(amax, np.amax(responses))
    amin *= 1.1
    amax *= 1.1

    # Calculate displacement with OpenSees via direct simulation.
    os_displacement = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_front_x],
            response_type=ResponseType.YTrans,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z)
                for sensor_x, sensor_z in displa_sensor_xzs
            ],
        ).T
        * 1000
    )
    amin = min(amin, np.amin(os_displacement))
    amax = max(amax, np.amax(os_displacement))

    def plot(i, sensor_label, meas_group):
        # Plot Diana predictions for the given sensor.
        if plot_diana:
            diana_sensor_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
            plt.plot(
                diana_sensor_group[&#34;xpostruck&#34;],
                diana_sensor_group[&#34;infline1&#34;],
                lw=lw,
                label=&#34;Diana&#34;,
            )

        # Plot values from OpenSees.
        plt.plot(
            truck_front_x, os_displacement[i], lw=lw, label=&#34;OpenSees&#34;, c=&#34;tab:blue&#34;
        )
        if i == 0:
            print(os_displacement[i])
            print(f&#34;Truck front (head) = {truck_front_x[:7]}&#34;)
            print(f&#34;Printed os_displacement&#34;)

        # Plot measured values sorted by truck position.
        sensor_x, sensor_z = displa_sensor_xzs[i]
        plt.scatter(
            meas_group[&#34;xpostruck&#34;],
            meas_group[&#34;inflinedata&#34;],
            s=size,
            label=&#34;Measurement&#34;,
            zorder=3,
            color=&#34;tab:red&#34;,
        )

        plt.scatter(
            [0],
            [0],
            label=f&#34;{sensor_label}: x = {np.around(sensor_x, 3)} m, z = {np.around(sensor_z, 3)} m&#34;,
            alpha=0,
        )

        legend_marker_size(plt.legend(), 80)
        plt.ylabel(f&#34;{ResponseType.YTrans.name()} (mm)&#34;)
        plt.ylim((amin, amax))

    # Create a subplot for each displacement sensor.
    plot_i, subplot_i = 0, 0
    for i, (sensor_label, meas_group) in enumerate(displa_groupby):
        plt.subplot(rows, 1, subplot_i + 1)
        plot(i, sensor_label, meas_group)
        if (subplot_i == rows - 1) or i == len(displa_groupby) - 1:
            plt.xlabel(&#34;X position of Truck 1&#39;s front axle (m)&#34;)
            plt.suptitle(
                &#34;Y translation from Truck 1 on bridge 705\nstatic simulation vs. static test&#34;
            )
            plt.tight_layout(rect=[0, 0.03, 1, 0.93])
            plt.savefig(c.get_image_path(&#34;validation/sensors&#34;, f&#34;displa-{plot_i}.pdf&#34;))
            plt.close()
            subplot_i = 0
            plot_i += 1
        else:
            plt.tick_params(axis=&#34;x&#34;, bottom=False, labelbottom=False)
            subplot_i += 1

    # Create any plots for individual sensors.
    plt.landscape()
    for i, (sensor_label, meas_group) in enumerate(displa_groupby):
        if sensor_label in individual_sensors:
            plot(i, sensor_label, meas_group)
            plt.tight_layout()
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;, f&#34;displa-sensor-{sensor_label}.pdf&#34;,
                )
            )
            plt.close()


def r2_plots(c: Config):
    &#34;&#34;&#34;R² plots for displacement and strain.&#34;&#34;&#34;
    rt_y = ResponseType.YTrans
    rt_s = ResponseType.StrainXXB

    ################
    # Displacement #
    ################

    # Sensor label, truck x position, and response value.
    displa_meas: List[Tuple[str, float, float]] = []
    displa_diana: List[Tuple[str, float, float]] = []
    # List of sensor labels and positions in the same order as above.
    sensors = []
    # All truck positions used in measurements.
    truck_xs_meas = set()

    # For each sensor and truck x position plot the recorded measurement and
    # Diana response.
    for row in _displa_sensors.itertuples():
        sensor_label = getattr(row, &#34;label&#34;)
        x, z = _displa_sensor_xz(sensor_label)
        sensors.append((sensor_label, x, z))
        responses = _meas[_meas[&#34;sensorlabel&#34;] == sensor_label]
        for sensor_row in responses.itertuples():
            truck_x = getattr(sensor_row, &#34;xpostruck&#34;)
            truck_xs_meas.add(truck_x)
            response = getattr(sensor_row, &#34;inflinedata&#34;)
            displa_meas.append((sensor_label, truck_x, response))
            displa_diana.append(
                diana_response(sensor_label=sensor_label, truck_x=truck_x)
            )
    truck_xs_meas = sorted(truck_xs_meas)

    # Displacement in OpenSees via direct simulation (measurement points).
    displa_os_meas = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_xs_meas],
            response_type=rt_y,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z) for _, sensor_x, sensor_z in sensors
            ],
        )
        * 1000
    )

    def get_os_meas(sensor_label: str, truck_x: float):
        for i, truck_x_ in enumerate(truck_xs_meas):
            if truck_x_ == truck_x:
                for j, (sensor_label_, _, _) in enumerate(sensors):
                    if sensor_label_ == sensor_label:
                        return displa_os_meas[i][j]
        raise ValueError(
            f&#34;No match. sensor_label = {sensor_label}, truck_x = {truck_x}&#34;
        )

    # Subplot: Diana against measurements.
    plt.portrait()
    plt.subplot(3, 1, 1)
    x = list(map(lambda x: x[2], displa_meas))
    y = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y, color=&#34;tab:blue&#34;)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: Diana vs. measurements&#34;)
    plt.xlabel(f&#34;{rt_y.name()} measurement (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in Diana (mm)&#34;)

    # Subplot: OpenSees against measurements.
    plt.subplot(3, 1, 2)
    x = list(map(lambda x: x[2], displa_meas))
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y, color=&#34;tab:blue&#34;)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: OpenSees vs. measurements&#34;)
    plt.xlabel(f&#34;{rt_y.name()} measurement (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in OpenSees (mm)&#34;)

    # Subplot: OpenSees against Diana.
    plt.subplot(3, 1, 3)
    x = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: OpenSees vs. Diana&#34;)
    plt.xlabel(f&#34;{rt_y.name()} in Diana (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in OpenSees (mm)&#34;)

    plt.tight_layout()
    plt.savefig(c.get_image_path(&#34;validation/regression&#34;, &#34;regression-displa.pdf&#34;))
    plt.close()

    ####################
    ###### Strain ######
    ####################

    # Sensor label, truck x position, and response value.
    strain_meas: List[Tuple[str, float, float]] = []
    strain_diana: List[Tuple[str, float, float]] = []
    # List of sensor labels and positions in the same order as above.
    sensors = []

    # For each sensor and truck x position record measurment and Diana response.
    count_nan = 0
    for row in _strain_sensors.itertuples():
        sensor_label = getattr(row, &#34;label&#34;)
        x, z = _strain_sensor_xz(sensor_label)
        sensors.append((sensor_label, x, z))
        responses = _meas[_meas[&#34;sensorlabel&#34;] == sensor_label]
        for sensor_row in responses.itertuples():
            truck_x = getattr(sensor_row, &#34;xpostruck&#34;)
            response = getattr(sensor_row, &#34;inflinedata&#34;)
            if not np.isnan(response):
                strain_meas.append((sensor_label, truck_x, response))
                strain_diana.append(
                    diana_response(sensor_label=sensor_label, truck_x=truck_x)
                )
            else:
                count_nan += 1

    print_i(f&#34;Count nan = {count_nan}&#34;)

    # Strain in OpenSees via direct simulation (measurement points).
    strain_os_meas = to_vehicles_direct(
        c=c,
        vehicles=[truck1],
        times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_xs_meas],
        response_type=rt_s,
        points=[
            Point(x=sensor_x, y=0, z=sensor_z) for _, sensor_x, sensor_z in sensors
        ],
    )

    def get_os_meas(sensor_label: str, truck_x: float):
        for i, truck_x_ in enumerate(truck_xs_meas):
            if truck_x_ == truck_x:
                for j, (sensor_label_, _, _) in enumerate(sensors):
                    if sensor_label_ == sensor_label:
                        return strain_os_meas[i][j]
        raise ValueError(
            f&#34;No match. sensor_label = {sensor_label}, truck_x = {truck_x}&#34;
        )

    # Subplot: Diana against measurements.
    plt.subplot(3, 1, 1)
    x = list(map(lambda x: x[2], strain_meas))
    y = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain XXB: Diana vs. measurements&#34;)
    plt.xlabel(&#34;Microstrain XXB measurement&#34;)
    plt.ylabel(&#34;Microstrain XXB in Diana&#34;)

    # Subplot: OpenSees against measurements.
    plt.subplot(3, 1, 2)
    x = list(map(lambda x: x[2], strain_meas))
    y = np.array(
        [
            get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
            for sensor_label, truck_x, _ in strain_meas
        ]
    )
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain XXB: OpenSees vs. measurements&#34;)
    plt.xlabel(&#34;Microstrain XXB measurement&#34;)
    plt.ylabel(&#34;Microstrain XXB in OpenSees&#34;)

    # Subplot: OpenSees against Diana.
    plt.subplot(3, 1, 3)
    x = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain: OpenSees vs. Diana&#34;)
    plt.xlabel(&#34;Microstrain XXB in Diana&#34;)
    plt.ylabel(&#34;Microstrain XXB in OpenSees&#34;)

    plt.tight_layout()
    plt.savefig(c.get_image_path(&#34;validation/regression&#34;, &#34;regression-strain.pdf&#34;))


def plot_pier_convergence(
    c: Config,
    process: int,
    pier_i: int,
    max_nodes: int,
    strain_ignore_radius: float,
    nesw_location: int,
    nesw_max_dist: float,
    min_shell_len: float,
    max_shell_len: Optional[float] = None,
):
    &#34;&#34;&#34;Plot pier convergence, increasing mesh density per simulation.&#34;&#34;&#34;
    # We will be modifying the &#39;Config&#39;, so make a copy.
    og_c = c
    c = deepcopy(c)
    sim_params = SimParams(
        response_types=[ResponseType.YTranslation, ResponseType.Strain],
        displacement_ctrl=PierSettlement(displacement=c.pd_unit_disp, pier=pier_i),
    )
    pier = c.bridge.supports[pier_i]
    if nesw_location == 0:
        nesw_point = Point(
            x=pier.x - (pier.length / 2), y=0, z=pier.z + (pier.width_top / 2)
        )
    else:
        raise ValueError(&#34;Invalid NESW plot location&#34;)
    if max_shell_len is None:
        max_shell_len = c.bridge.length / 10
    # Construct a function to ignore fem, this is around pier lines.
    without = without.pier_lines(c=c, radius=strain_ignore_radius)

    def update_bridge():
        c.bridge.name = &#34;Bridge 705&#34;
        c.bridge.accuracy = f&#34;convergence-pier-{pier_i}-{max_shell_len}&#34;
        c.bridge.base_mesh_deck_max_x = max_shell_len
        c.bridge.base_mesh_deck_max_z = max_shell_len
        c.bridge.base_mesh_pier_max_long = max_shell_len
        return c.bridge

    # Write parameter information to the results file.
    filepath = c.get_image_path(
        &#34;convergence-pier&#34;,
        safe_str(f&#34;{c.bridge.name}-{process}-convergence-results-pier-{pier_i}&#34;)
        + &#34;.csv&#34;,
        # We are storing results for all model sizes in the same file, so no
        # need for bridge accuracy in filepath.
        acc=False,
    )
    print_i(f&#34;Expecting parameters at {filepath}&#34;)

    if not os.path.exists(filepath):
        print_i(filepath)
        # Parameters of simulations are written to a file.
        df = pd.DataFrame(
            columns=[
                &#34;deck-nodes&#34;,
                &#34;pier-nodes&#34;,
                &#34;time&#34;,
                &#34;shell-size&#34;,
                &#34;deck-size&#34;,
                &#34;pier-size&#34;,
            ]
        )
        df.index.name = &#34;max-shell-len&#34;
        df.to_csv(filepath)
    df = pd.read_csv(filepath, index_col=&#34;max-shell-len&#34;)

    max_shell_lens = list(np.arange(max_shell_len, 2 - 0.00001, -1))
    max_shell_lens += list(np.arange(1.9, 1 - 0.00001, -0.1))
    max_shell_lens += list(np.arange(0.9, 0.1 - 0.00001, -0.01))
    max_shell_lens = list(map(round_m, max_shell_lens))
    max_shell_lens = [msl for msl in max_shell_lens if msl &lt;= max_shell_len]
    max_shell_lens = [msl for msl in max_shell_lens if msl &gt;= min_shell_len]
    print_i(f&#34;Max shell lens = {max_shell_lens}&#34;)

    # Load fem for each parameter setting. If the simulation has not run
    # yet then it will be run and the parameter settings saved.
    all_displacements = dict()
    all_strains = dict()
    for max_shell_len in max_shell_lens:
        print(f&#34;max shell len = {max_shell_len}&#34;)
        update_bridge()
        try:
            # Start timing and load the results into memory.
            start = timer()
            displacements = load_fem_responses(
                c=c,
                sim_params=sim_params,
                response_type=ResponseType.YTranslation,
                sim_runner=OSRunner(c),
            )
            all_displacements[max_shell_len] = displacements
            strains = load_fem_responses(
                c=c,
                sim_params=sim_params,
                response_type=ResponseType.Strain,
                sim_runner=OSRunner(c),
            )
            all_strains[max_shell_len] = strains.resize()
            end = timer()
            # If the simulation was run, then nodes from the built FEM will be
            # attached. In that case save the paramameters.
            if hasattr(sim_params, &#34;bridge_nodes&#34;):
                nodes = det_nodes(sim_params.bridge_nodes)
                # Clear the parameter, so the test works next iteration.
                del sim_params.bridge_nodes
                deck_nodes = len([n for n in nodes if n.deck])
                pier_nodes = len([n for n in nodes if not n.deck])
                assert deck_nodes + pier_nodes == len(nodes)
                # Determine shell sizes for the deck, pier and whole bridge.
                shells = det_shells(sim_params.bridge_shells)
                avg_shell_size = np.mean([s.area() for s in shells])
                avg_deck_size = np.mean([s.area() for s in shells if not s.pier])
                avg_pier_size = np.mean([s.area() for s in shells if s.pier])
                # Add the new parameters to the DataFrame and write to disk.
                if max_shell_len in df.index:
                    df.drop(max_shell_len)
                df.append(pd.Series(name=max_shell_len))
                for param_name, param in [
                    (&#34;deck-nodes&#34;, deck_nodes),
                    (&#34;pier-nodes&#34;, pier_nodes),
                    (&#34;time&#34;, end - start),
                    (&#34;shell-size&#34;, avg_shell_size),
                    (&#34;deck-size&#34;, avg_deck_size),
                    (&#34;pier-size&#34;, avg_pier_size),
                ]:
                    df.at[max_shell_len, param_name] = param
                df.to_csv(filepath)
            row = df.loc[max_shell_len, :]
            # Stop the simulation if maximum amount of nodes are reached.
            if float(row[&#34;deck-nodes&#34;]) + float(row[&#34;pier-nodes&#34;]) &gt; max_nodes:
                print_i(&#34;Maximum nodes reached&#34;)
                break
            # TODO: Remove to deck interpolation test.
            # for x in displacements.xs:
            #     if 0 in displacements.zs[x]:
            #         for z in displacements.zs[x][0]:
            #             og = displacements.fem[0][x][0][z]
            #             ip = displacements.at_deck(Point(x=x, y=0, z=z), interp=True)
            #             assert np.isclose(og, ip)
        except ValueError as e:
            if &#34;No fem found&#34; in str(e):
                print_i(&#34;Simulation failed. Time to plot results&#34;)
                break
            else:
                raise e

    plot_nesw_convergence(
        c=og_c,
        df=df,
        responses=all_strains,
        point=nesw_point,
        max_distance=nesw_max_dist,
        from_=f&#34;the NW point of pier {pier_i}&#34;,
    )
    filepath = og_c.get_image_path(
        &#34;convergence-pier&#34;,
        safe_str(f&#34;{og_c.bridge.name}-{process}-convergence-nesw-pier-{pier_i}&#34;)
        + &#34;.pdf&#34;,
        acc=False,
    )
    plt.savefig(filepath)
    plt.close()

    # For each set of fem remove the removed points.
    # for key, displacements in all_displacements.items():
    #     all_displacements[key] = displacements.without(without)
    #     print(f&#34;Filtering displacements with max shell len {key}&#34;, end=&#34;\r&#34;)
    # print()

    # Plot convergence of strain, first with all sensors, then without some.
    title = f&#34;Strain convergence as a function of model size\ndue to settlement of pier {pier_i}&#34;
    plot_mmm_strain_convergence(
        c=og_c, pier=pier, df=df, all_strains=all_strains, title=title, append=&#34;0&#34;
    )
    plot_mmm_strain_convergence(
        c=og_c,
        pier=pier,
        df=df,
        all_strains=all_strains,
        title=title,
        without=without,
        append=f&#34;{strain_ignore_radius}&#34;,
    )


def make_convergence_data(c: Config, x: float = 34.955, z: float = 29.226 - 16.6):
    &#34;&#34;&#34;Make convergence data file, increasing mesh density per simulation.&#34;&#34;&#34;
    load_point = Point(x=x, y=0, z=z)
    bridge = bridge_705_3d()
    fem_params = SimParams(
        ploads=[
            PointLoad(
                x_frac=bridge.x_frac(load_point.x),
                z_frac=bridge.z_frac(load_point.z),
                kn=100,
            )
        ],
        response_types=[ResponseType.YTranslation, ResponseType.Strain],
    )
    max_shell_len = 10

    def bridge_overload(**kwargs):
        return bridge_705_3d(
            name=f&#34;Bridge 705&#34;,
            accuracy=&#34;convergence&#34;,
            base_mesh_deck_max_x=max_shell_len,
            base_mesh_deck_max_z=max_shell_len,
            base_mesh_pier_max_long=max_shell_len,
            **kwargs,
        )

    # A grid of points over which to calculate the mean response. The reason for
    # this is because if the number of nodes increases, as model size increases,
    # then there will be an increase in nodes where fem are large, thus
    # model size will influence the mean/min calculation.
    grid = [
        Point(x=x, y=0, z=z)
        for x, z in itertools.product(
            np.linspace(c.bridge.x_min, c.bridge.x_max, int(c.bridge.length)),
            np.linspace(c.bridge.z_min, c.bridge.z_max, int(c.bridge.width)),
        )
    ]

    # Write the header information to the results file.
    c = bridge_705_config(bridge_overload)
    path = c.get_image_path(&#34;convergence&#34;, &#34;convergence_results&#34;, bridge=False)
    with open(path + &#34;.txt&#34;, &#34;w&#34;) as f:
        f.write(
            &#34;xload,zload,max_mesh,decknodes,piernodes,time&#34;
            + &#34;,min_d,max_d,mean_d,min_s,max_s,mean_s,shell-size,deck-size,pier-size&#34;
        )
    # Header information for a second file, recording strain close to the load.
    strain_path = c.get_image_path(&#34;convergence&#34;, &#34;strain-inf.txt&#34;, bridge=False)
    with open(strain_path, &#34;w&#34;) as f:
        # Simulation parameters, direction recording, and recordings.
        f.write(&#34;max_mesh,decknodes,piernodes,dir,recs&#34;)

    max_shell_lens = list(np.arange(10, 2 - 0.00001, -1))
    max_shell_lens += list(np.arange(1.9, 1 - 0.00001, -0.1))
    max_shell_lens += list(np.arange(0.9, 0.1 - 0.00001, -0.01))
    max_shell_lens = list(map(round_m, max_shell_lens))

    for max_shell_len in max_shell_lens:

        print(f&#34;max shell len = {max_shell_len}&#34;)

        with open(path + &#34;.txt&#34;, &#34;a&#34;) as f:
            f.write(f&#34;\n{load_point.x}, {load_point.z}, {max_shell_len}&#34;)

        c = bridge_705_config(bridge_overload)
        try:
            # Start timing and run the simulation.
            start = timer()
            displacements = load_fem_responses(
                c=c,
                sim_params=fem_params,
                response_type=ResponseType.YTranslation,
                sim_runner=OSRunner(c),
                run=True,
            )
            end = timer()

            # Determine amount of nodes.
            nodes = det_nodes(fem_params.bridge_nodes)
            deck_nodes = len([n for n in nodes if n.deck])
            pier_nodes = len([n for n in nodes if not n.deck])

            # Determine shell sizes for the deck, pier and whole bridge.
            shells = det_shells(fem_params.bridge_shells)
            avg_deck_size = np.mean([s.area() for s in shells if not s.pier])
            avg_pier_size = np.mean([s.area() for s in shells if s.pier])
            avg_shell_size = np.mean([s.area() for s in shells])

            # TODO: Remove to deck interpolation test.
            for x in displacements.xs:
                if 0 in displacements.zs[x]:
                    for z in displacements.zs[x][0]:
                        og = bridge_sim.sim.responses.responses[0][x][0][z].value
                        ip = displacements.at_deck(Point(x=x, y=0, z=z), interp=True)
                        assert np.isclose(og, ip)

            # Determine min, max and mean displacements.
            all_displacements = np.array(list(displacements.values()))
            grid_displacements = np.array(
                [displacements.at_deck(point, interp=True) for point in grid]
            )

            # Minimum displacement is under the load.
            min_d = scalar(np.min(all_displacements))
            max_d = scalar(np.max(grid_displacements))
            mean_d = scalar(np.mean(grid_displacements))

            strains = load_fem_responses(
                c=c,
                sim_params=fem_params,
                response_type=ResponseType.Strain,
                sim_runner=OSRunner(c),
            )
            all_strains = np.array(list(strains.values()))
            grid_strains = np.array(
                [strains.at_deck(point, interp=True) for point in grid]
            )
            min_s = scalar(np.min(grid_strains))
            # Maximum strain is under the load.
            max_s = scalar(np.max(all_strains))
            mean_s = scalar(np.mean(grid_strains))

            # Write results for this simulation to disk.
            with open(path + &#34;.txt&#34;, &#34;a&#34;) as f:
                f.write(
                    f&#34;, {deck_nodes}, {pier_nodes}, {end - start}&#34;
                    f&#34;, {min_d}, {max_d}, {mean_d}&#34;
                    f&#34;, {min_s}, {max_s}, {mean_s}&#34;
                    f&#34;, {avg_shell_size}, {avg_deck_size}, {avg_pier_size}&#34;
                )

            # Also write results of strain recordings, for each direction.
            for dir_name, x_mul, z_mul in [
                (&#34;N&#34;, 0, 1),
                (&#34;E&#34;, -1, 0),
                (&#34;S&#34;, 0, -1),
                (&#34;W&#34;, 1, 0),
            ]:
                recordings = []
                for delta in np.arange(0, 5, 0.05):
                    strain_point = Point(
                        x=load_point.x + (delta * x_mul),
                        y=load_point.y,
                        z=load_point.z + (delta * z_mul),
                    )
                    if (
                        strain_point.x &lt; c.bridge.x_min
                        or strain_point.x &gt; c.bridge.x_max
                        or strain_point.z &lt; c.bridge.z_min
                        or strain_point.z &gt; c.bridge.z_max
                    ):
                        break
                    print(strain_point.x, strain_point.z)
                    recordings.append(strains.at_deck(strain_point, interp=True))
                with open(strain_path, &#34;a&#34;) as f:
                    f.write(
                        f&#34;\n{max_shell_len}, {deck_nodes}, {pier_nodes}, {dir_name}, {recordings}&#34;
                    )

        except ValueError as e:
            if &#34;No fem found&#34; in str(e):
                print_i(&#34;Simulation failed. Time to plot results&#34;)
            else:
                raise e


def plot_nesw_strain_convergence(c: Config, filepath: str, from_: str, label: str):
    &#34;&#34;&#34;Plot convergence of strain at different points around a load.&#34;&#34;&#34;
    headers = [&#34;max_shell_len&#34;, &#34;decknodes&#34;, &#34;piernodes&#34;, &#34;compass&#34;, &#34;fem&#34;]
    parsed_lines = []
    with open(filepath) as f:
        lines = list(map(lambda l: l.split(&#34;,&#34;, len(headers) - 1), f.readlines()[1:]))
    for max_mesh, deck_nodes, pier_nodes, compass, responses in lines:
        parsed_lines.append(
            [
                float(max_mesh),
                float(deck_nodes),
                float(pier_nodes),
                compass.strip(),
                np.array(
                    list(
                        map(
                            float,
                            responses.replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).split(&#34;,&#34;),
                        )
                    )
                ),
            ]
        )
    df = pd.DataFrame(parsed_lines, columns=headers)
    # First find the maximum distance traversed.
    delta_distance = 0.05
    max_distance = 0
    for compass in [&#34;N&#34;, &#34;S&#34;, &#34;E&#34;, &#34;W&#34;]:
        compass_df = df[df[&#34;compass&#34;] == compass]
        responses = compass_df.iloc[0][&#34;fem&#34;]
        max_distance = max(len(responses) * delta_distance, max_distance)
    # Overriding maximum distance.
    # max_distance = 4
    # Create color mappable for distances.
    norm = matplotlib.colors.Normalize(vmin=0, vmax=max_distance)
    cmap = cm.get_cmap(&#34;jet&#34;)
    mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
    color = lambda d: mappable.to_rgba(d)
    # For each compass point.
    plt.square()
    fig, axes = plt.subplots(nrows=2, ncols=2)
    for ax, compass, compass_name, in zip(
        axes.flat, [&#34;N&#34;, &#34;S&#34;, &#34;E&#34;, &#34;W&#34;], [&#34;North&#34;, &#34;South&#34;, &#34;East&#34;, &#34;West&#34;]
    ):
        # Collect data into fem per max_shell_len.
        lines = {}
        compass_df = df[df[&#34;compass&#34;] == compass]
        for df_i, row in compass_df.iterrows():
            lines[row[&#34;max_shell_len&#34;]] = row[&#34;fem&#34;]
        # Restructure data into lines for plotting.
        max_shell_lens = []
        sorted_lines = []
        for max_shell_len in sorted(lines.keys()):
            max_shell_lens.append(max_shell_len)
            sorted_lines.append(lines[max_shell_len])
        sorted_lines = np.array(sorted_lines).T
        # Finally plot every nth line.
        distance = 0
        skip = 3
        for responses in sorted_lines[::skip]:
            ax.plot(max_shell_lens, responses, color=color(distance))
            distance += skip * delta_distance
            if distance &gt; max_distance:
                break
        ax.set_xlim(2, min(max_shell_lens))
        ax.set_title(
            f&#34;Strain at increasing distance\nin direction {compass_name} from\n{from_}&#34;
        )
        ax.set_xlabel(&#34;MSL (m)&#34;)
        ax.set_ylabel(&#34;Strain&#34;)
        ax.grid(axis=&#34;y&#34;)
    plt.tight_layout()
    clb = plt.colorbar(mappable, ax=axes.ravel())
    clb.ax.set_title(&#34;Distance (m)&#34;)
    plt.savefig(
        c.get_image_path(&#34;convergence&#34;, f&#34;convergencestrain-{label}.pdf&#34;, bridge=False)
    )
    plt.close()


def plot_convergence(c: Config):
    &#34;&#34;&#34;Plot convergence as model size is increased.

    Loads files named &#39;convergence-*&#39;, generated by &#39;make_convergence&#39; and
    renamed manually by you. Note that the &#39;*&#39; indicates the plot label which
    will be put in the legend.

    &#34;&#34;&#34;
    convergence_dir = os.path.dirname(
        c.get_image_path(&#34;convergence&#34;, &#34;_&#34;, bridge=False)
    )

    # Get all simulations results from each machine.
    machines = dict()
    for filepath in glob.glob(os.path.join(convergence_dir, &#34;convergence-*&#34;)):
        machine_name = os.path.basename(filepath).split(&#34;-&#34;)[1].split(&#34;.&#34;)[0]
        machines[machine_name] = pd.read_csv(filepath).dropna()

    if len(machines) == 0:
        raise ValueError(f&#34;No results found in {convergence_dir}&#34;)

    # Map from machine name to loading position to list of Series.
    machine_results = defaultdict(lambda: defaultdict(list))
    for machine_name, df in machines.items():
        for _, row in df.iterrows():
            x_load, z_load = row[&#34;xload&#34;], row[&#34;zload&#34;]
            machine_results[machine_name][(x_load, z_load)].append(row)

    # Map from machine name to loading position to list of lines to plot.
    results = defaultdict(dict)
    for machine_name, loading_pos_dict in machine_results.items():
        for (x_load, z_load), rows in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = (
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            )
            for row in rows:
                max_mesh.append(row[&#34;max_mesh&#34;])
                mins_d.append(row[&#34;min_d&#34;])
                maxes_d.append(row[&#34;max_d&#34;])
                means_d.append(row[&#34;mean_d&#34;])
                mins_s.append(row[&#34;min_s&#34;])
                maxes_s.append(row[&#34;max_s&#34;])
                means_s.append(row[&#34;mean_s&#34;])
                time.append(row[&#34;time&#34;])
                ndeck.append(row[&#34;decknodes&#34;])
                npier.append(row[&#34;piernodes&#34;])
                shell_size.append(row[&#34;shell-size&#34;])
                deck_shell_size.append(row[&#34;deck-size&#34;])
                pier_shell_size.append(row[&#34;pier-size&#34;])
            results[machine_name][(x_load, z_load)] = list(
                map(
                    np.array,
                    [
                        max_mesh,
                        mins_d,
                        maxes_d,
                        means_d,
                        mins_s,
                        maxes_s,
                        means_s,
                        time,
                        ndeck,
                        npier,
                        shell_size,
                        deck_shell_size,
                        pier_shell_size,
                    ],
                )
            )

    def plot_intersection(x, xs, ys, of=None, units=None):
        y = np.interp(x, xs, ys)
        y_frac = y / ys[-1]
        y_percent = y_frac * 100
        label = None
        if of is not None:
            label = f&#34;{y_percent:.2f}% of {of}&#34;
        if units is not None:
            label = f&#34;{units} = {y:.2f}&#34;
        plt.axvline(x, label=label, color=&#34;black&#34;)

    CHOSEN_NUM_NODES = 24500

    ########################################
    ###### Min. and max. per machine #######
    ########################################

    # Displacement
    plt.landscape()
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            num_nodes = ndeck + npier
            final_mean_d = np.mean(means_d[-5:])
            final_max_d = np.mean(maxes_d[-5:])
            final_min_d = np.mean(mins_d[-5:])
            plt.plot(
                num_nodes, mins_d / final_min_d, color=&#34;red&#34;, label=&#34;Min. response&#34;
            )
            plt.plot(
                num_nodes, maxes_d / final_max_d, color=&#34;orange&#34;, label=&#34;Max. response&#34;,
            )
            plt.plot(
                num_nodes, means_d / final_mean_d, color=&#34;green&#34;, label=&#34;Mean response&#34;,
            )
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, mins_d / final_min_d, &#34;min&#34;)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, maxes_d / final_max_d, &#34;max&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, means_d / final_mean_d, &#34;mean&#34;
            )
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Normalized y translation as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Normalized y translation&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;min-max-displa.pdf&#34;, bridge=False))
    plt.close()

    # Strain
    plt.landscape()
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            num_nodes = ndeck + npier
            final_mean_s = np.mean(means_s[-5:])
            final_max_s = np.mean(maxes_s[-5:])
            final_min_s = np.mean(mins_s[-5:])
            plt.plot(
                num_nodes, mins_s / final_min_s, color=&#34;red&#34;, label=&#34;Min. response&#34;
            )
            plt.plot(
                num_nodes, maxes_s / final_max_s, color=&#34;orange&#34;, label=&#34;Max. response&#34;,
            )
            plt.plot(
                num_nodes, means_s / final_mean_s, color=&#34;green&#34;, label=&#34;Mean response&#34;,
            )
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, mins_s / final_min_s, &#34;min&#34;)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, maxes_s / final_max_s, &#34;max&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, means_s / final_mean_s, &#34;mean&#34;
            )

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Normalized strain as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Normalized strain&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;min-max-strain.pdf&#34;, bridge=False))
    plt.close()

    #########################
    ###### Model size #######
    #########################

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = ndeck + npier
            plt.plot(num_nodes, shell_size, label=&#34;Mean shell area&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, shell_size, units=&#34;Shell area (m²)&#34;
            )
        break

    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Mean shell area as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Shell area (m²)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;model-size.pdf&#34;, bridge=False))
    plt.close()

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            # plt.plot(max_mesh, max_mesh, label=&#34;Max. shell length parameter&#34;)
            plt.plot(max_mesh, shell_size)
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Mean shell area as a function of max. shell length parameter&#34;)
    plt.xlabel(&#34;Max. shell length parameter (m)&#34;)
    plt.ylabel(&#34;Shell area (m²)&#34;)
    # plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;model-size-param.pdf&#34;, bridge=False))
    plt.close()

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = ndeck + npier
            plt.plot(num_nodes, max_mesh)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, max_mesh, units=&#34;Shell length (m)&#34;
            )
        break

    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Max. shell length parameter as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Max. shell length parameter (m)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;chosen-param.pdf&#34;, bridge=False))
    plt.close()

    ###################################
    ###### Run time per machine #######
    ###################################

    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = (ndeck + npier)[:-1]
            times = time[:-1]
            plt.plot(num_nodes, times)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, times, units=&#34;Run time (s)&#34;)
            print_w(&#34;Removed one outlier!&#34;)
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Run-time as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Run-time (s)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;run-time.pdf&#34;, bridge=False))
    plt.close()

    #########################################
    ###### Individual: min, max, mean #######
    #########################################

    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            plt.plot(ndeck + npier, maxes_d)
            plt.title(&#34;Maximum displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Maximum displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacement-max-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            plt.plot(ndeck + npier, mins_d)
            plt.title(&#34;Minimum displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Minimum displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacement-min-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            plt.plot(ndeck + npier, means_d)
            plt.title(&#34;Mean displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Mean displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacment-mean-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            ############################################
            ###### Individual: Mean element size #######
            ############################################

            plt.plot(shell_size, shell_size, label=&#34;Mean shell area&#34;)
            plt.plot(shell_size, deck_shell_size, label=&#34;Mean deck shell area&#34;)
            plt.plot(shell_size, pier_shell_size, label=&#34;Mean pier shell area&#34;)
            # plt.xlim(plt.xlim()[1], plt.xlim()[0])
            # plt.ylim(plt.ylim()[1], plt.ylim()[0])
            plt.legend()
            plt.title(&#34;Mean shell area&#34;)
            plt.xlabel(&#34;Mean shell area (m²)&#34;)
            plt.ylabel(&#34;Mean shell area (m²)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;mean-element-size-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()


def axis_comparison(c: Config):
    &#34;&#34;&#34;&#34;&#34;&#34;
    if len(c.bridge.sections) &gt; 1:
        raise ValueError(&#34;Bridge deck has more than one section&#34;)
    for pier in c.bridge.supports:
        if len(pier.sections) &gt; 1:
            raise ValueError(f&#34;Bridge pier {pier} has more than one section&#34;)

    ###############################
    ###### Point load plots #######
    ###############################

    positions = [(35, 25 - 16.6)]
    response_types = [ResponseType.YTranslation]
    for response_type in response_types:
        for load_x, load_z in positions:
            loads = [
                PointLoad(
                    x_frac=c.bridge.x_frac(load_x),
                    z_frac=c.bridge.z_frac(load_z),
                    kn=100,
                )
            ]
            fem_responses = load_fem_responses(
                c=c,
                response_type=response_type,
                sim_runner=OSRunner(c),
                sim_params=SimParams(ploads=loads, response_types=response_types),
            )
            title = (
                f&#34;{response_type.name()} from a {loads[0].kn} kN point load&#34;
                + f&#34; at x = {load_x:.3f}m, z = {load_z:.3f}m&#34;
            )
            save = lambda prefix: c.get_image_path(
                &#34;contour-axis-comparison&#34;,
                safe_str(
                    f&#34;{prefix}{response_type.name()}-loadx={load_x:.3f}-loadz={load_z:.3f}&#34;
                ),
            )
            top_view_bridge(c.bridge, piers=True, abutments=True)
            contour_responses(
                c=c, responses=fem_responses, ploads=loads, title=title,
            )
            plt.savefig(save(&#34;&#34;))
            plt.close()


def temp_plots():
    sensors = [&#34;TA&#34;, &#34;TB&#34;, &#34;TC&#34;, &#34;U13&#34;, &#34;U26&#34;, &#34;U29&#34;]
    data_path = &#34;validation/sensors&#34;
    times, temps, responses = [], [], [[] for _ in sensors]
    for i in range(1, 13 + 1):
        # Times.
        times_path = os.path.join(data_path, f&#34;times{i}.csv&#34;)
        with open(times_path) as f:
            lines = f.read().split(&#34;,&#34;)
        parse_time = lambda l: datetime.strptime(l.split()[1], &#34;%H:%M:%S&#34;)
        times.append(list(map(parse_time, lines)))
        # Temps.
        temps_path = os.path.join(data_path, f&#34;temps{i}.csv&#34;)
        with open(temps_path) as f:
            lines = f.read().split(&#34;,&#34;)
        temps.append(list(map(float, lines)))
        assert len(times[-1]) == len(temps[-1])
        # Sensors.
        for s_i, sensor in enumerate(sensors):
            sensor_path = os.path.join(data_path, f&#34;{sensor}{i}.csv&#34;)
            with open(sensor_path) as f:
                lines = f.read().split(&#34;,&#34;)
            sensor_responses = list(map(float, lines))
            responses[s_i].append(sensor_responses)
            assert len(responses[s_i][-1]) == len(temps[-1])
    # Plot times versus temperatures.
    all_times = np.concatenate(times)
    all_temps = np.concatenate(temps)
    assert len(all_times) == len(all_temps)
    plt.scatter(all_times, all_temps)
    plt.title(&#34;Time versus temperature&#34;)
    plt.show()
    for s_i, sensor in enumerate(sensors):
        # sensor_responses = np.concatenate(fem[s_i])
        sensor_responses = [responses[s_i][i][0] for i in range(13)]
        plot_temps = [temps[i][0] for i in range(13)]
        # assert len(sensor_responses) == len(all_times)
        plt.scatter(plot_temps, sensor_responses)
        plt.show()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bridge_sim.internal.make.plot.verification.axis_comparison"><code class="name flex">
<span>def <span class="ident">axis_comparison</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axis_comparison(c: Config):
    &#34;&#34;&#34;&#34;&#34;&#34;
    if len(c.bridge.sections) &gt; 1:
        raise ValueError(&#34;Bridge deck has more than one section&#34;)
    for pier in c.bridge.supports:
        if len(pier.sections) &gt; 1:
            raise ValueError(f&#34;Bridge pier {pier} has more than one section&#34;)

    ###############################
    ###### Point load plots #######
    ###############################

    positions = [(35, 25 - 16.6)]
    response_types = [ResponseType.YTranslation]
    for response_type in response_types:
        for load_x, load_z in positions:
            loads = [
                PointLoad(
                    x_frac=c.bridge.x_frac(load_x),
                    z_frac=c.bridge.z_frac(load_z),
                    kn=100,
                )
            ]
            fem_responses = load_fem_responses(
                c=c,
                response_type=response_type,
                sim_runner=OSRunner(c),
                sim_params=SimParams(ploads=loads, response_types=response_types),
            )
            title = (
                f&#34;{response_type.name()} from a {loads[0].kn} kN point load&#34;
                + f&#34; at x = {load_x:.3f}m, z = {load_z:.3f}m&#34;
            )
            save = lambda prefix: c.get_image_path(
                &#34;contour-axis-comparison&#34;,
                safe_str(
                    f&#34;{prefix}{response_type.name()}-loadx={load_x:.3f}-loadz={load_z:.3f}&#34;
                ),
            )
            top_view_bridge(c.bridge, piers=True, abutments=True)
            contour_responses(
                c=c, responses=fem_responses, ploads=loads, title=title,
            )
            plt.savefig(save(&#34;&#34;))
            plt.close()</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.diana_response"><code class="name flex">
<span>def <span class="ident">diana_response</span></span>(<span>sensor_label: str, truck_x: float)</span>
</code></dt>
<dd>
<div class="desc"><p>Strain or displacement from Diana for a sensor and truck position.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diana_response(sensor_label: str, truck_x: float):
    &#34;&#34;&#34;Strain or displacement from Diana for a sensor and truck position.&#34;&#34;&#34;
    if sensor_label not in diana_interp_funcs:
        all_sensors = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        diana_interp_funcs[sensor_label] = interp1d(
            all_sensors[&#34;xpostruck&#34;], all_sensors[&#34;infline1&#34;]
        )
    return diana_interp_funcs[sensor_label](truck_x)</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.make_convergence_data"><code class="name flex">
<span>def <span class="ident">make_convergence_data</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>, x: float = 34.955, z: float = 12.625999999999998)</span>
</code></dt>
<dd>
<div class="desc"><p>Make convergence data file, increasing mesh density per simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_convergence_data(c: Config, x: float = 34.955, z: float = 29.226 - 16.6):
    &#34;&#34;&#34;Make convergence data file, increasing mesh density per simulation.&#34;&#34;&#34;
    load_point = Point(x=x, y=0, z=z)
    bridge = bridge_705_3d()
    fem_params = SimParams(
        ploads=[
            PointLoad(
                x_frac=bridge.x_frac(load_point.x),
                z_frac=bridge.z_frac(load_point.z),
                kn=100,
            )
        ],
        response_types=[ResponseType.YTranslation, ResponseType.Strain],
    )
    max_shell_len = 10

    def bridge_overload(**kwargs):
        return bridge_705_3d(
            name=f&#34;Bridge 705&#34;,
            accuracy=&#34;convergence&#34;,
            base_mesh_deck_max_x=max_shell_len,
            base_mesh_deck_max_z=max_shell_len,
            base_mesh_pier_max_long=max_shell_len,
            **kwargs,
        )

    # A grid of points over which to calculate the mean response. The reason for
    # this is because if the number of nodes increases, as model size increases,
    # then there will be an increase in nodes where fem are large, thus
    # model size will influence the mean/min calculation.
    grid = [
        Point(x=x, y=0, z=z)
        for x, z in itertools.product(
            np.linspace(c.bridge.x_min, c.bridge.x_max, int(c.bridge.length)),
            np.linspace(c.bridge.z_min, c.bridge.z_max, int(c.bridge.width)),
        )
    ]

    # Write the header information to the results file.
    c = bridge_705_config(bridge_overload)
    path = c.get_image_path(&#34;convergence&#34;, &#34;convergence_results&#34;, bridge=False)
    with open(path + &#34;.txt&#34;, &#34;w&#34;) as f:
        f.write(
            &#34;xload,zload,max_mesh,decknodes,piernodes,time&#34;
            + &#34;,min_d,max_d,mean_d,min_s,max_s,mean_s,shell-size,deck-size,pier-size&#34;
        )
    # Header information for a second file, recording strain close to the load.
    strain_path = c.get_image_path(&#34;convergence&#34;, &#34;strain-inf.txt&#34;, bridge=False)
    with open(strain_path, &#34;w&#34;) as f:
        # Simulation parameters, direction recording, and recordings.
        f.write(&#34;max_mesh,decknodes,piernodes,dir,recs&#34;)

    max_shell_lens = list(np.arange(10, 2 - 0.00001, -1))
    max_shell_lens += list(np.arange(1.9, 1 - 0.00001, -0.1))
    max_shell_lens += list(np.arange(0.9, 0.1 - 0.00001, -0.01))
    max_shell_lens = list(map(round_m, max_shell_lens))

    for max_shell_len in max_shell_lens:

        print(f&#34;max shell len = {max_shell_len}&#34;)

        with open(path + &#34;.txt&#34;, &#34;a&#34;) as f:
            f.write(f&#34;\n{load_point.x}, {load_point.z}, {max_shell_len}&#34;)

        c = bridge_705_config(bridge_overload)
        try:
            # Start timing and run the simulation.
            start = timer()
            displacements = load_fem_responses(
                c=c,
                sim_params=fem_params,
                response_type=ResponseType.YTranslation,
                sim_runner=OSRunner(c),
                run=True,
            )
            end = timer()

            # Determine amount of nodes.
            nodes = det_nodes(fem_params.bridge_nodes)
            deck_nodes = len([n for n in nodes if n.deck])
            pier_nodes = len([n for n in nodes if not n.deck])

            # Determine shell sizes for the deck, pier and whole bridge.
            shells = det_shells(fem_params.bridge_shells)
            avg_deck_size = np.mean([s.area() for s in shells if not s.pier])
            avg_pier_size = np.mean([s.area() for s in shells if s.pier])
            avg_shell_size = np.mean([s.area() for s in shells])

            # TODO: Remove to deck interpolation test.
            for x in displacements.xs:
                if 0 in displacements.zs[x]:
                    for z in displacements.zs[x][0]:
                        og = bridge_sim.sim.responses.responses[0][x][0][z].value
                        ip = displacements.at_deck(Point(x=x, y=0, z=z), interp=True)
                        assert np.isclose(og, ip)

            # Determine min, max and mean displacements.
            all_displacements = np.array(list(displacements.values()))
            grid_displacements = np.array(
                [displacements.at_deck(point, interp=True) for point in grid]
            )

            # Minimum displacement is under the load.
            min_d = scalar(np.min(all_displacements))
            max_d = scalar(np.max(grid_displacements))
            mean_d = scalar(np.mean(grid_displacements))

            strains = load_fem_responses(
                c=c,
                sim_params=fem_params,
                response_type=ResponseType.Strain,
                sim_runner=OSRunner(c),
            )
            all_strains = np.array(list(strains.values()))
            grid_strains = np.array(
                [strains.at_deck(point, interp=True) for point in grid]
            )
            min_s = scalar(np.min(grid_strains))
            # Maximum strain is under the load.
            max_s = scalar(np.max(all_strains))
            mean_s = scalar(np.mean(grid_strains))

            # Write results for this simulation to disk.
            with open(path + &#34;.txt&#34;, &#34;a&#34;) as f:
                f.write(
                    f&#34;, {deck_nodes}, {pier_nodes}, {end - start}&#34;
                    f&#34;, {min_d}, {max_d}, {mean_d}&#34;
                    f&#34;, {min_s}, {max_s}, {mean_s}&#34;
                    f&#34;, {avg_shell_size}, {avg_deck_size}, {avg_pier_size}&#34;
                )

            # Also write results of strain recordings, for each direction.
            for dir_name, x_mul, z_mul in [
                (&#34;N&#34;, 0, 1),
                (&#34;E&#34;, -1, 0),
                (&#34;S&#34;, 0, -1),
                (&#34;W&#34;, 1, 0),
            ]:
                recordings = []
                for delta in np.arange(0, 5, 0.05):
                    strain_point = Point(
                        x=load_point.x + (delta * x_mul),
                        y=load_point.y,
                        z=load_point.z + (delta * z_mul),
                    )
                    if (
                        strain_point.x &lt; c.bridge.x_min
                        or strain_point.x &gt; c.bridge.x_max
                        or strain_point.z &lt; c.bridge.z_min
                        or strain_point.z &gt; c.bridge.z_max
                    ):
                        break
                    print(strain_point.x, strain_point.z)
                    recordings.append(strains.at_deck(strain_point, interp=True))
                with open(strain_path, &#34;a&#34;) as f:
                    f.write(
                        f&#34;\n{max_shell_len}, {deck_nodes}, {pier_nodes}, {dir_name}, {recordings}&#34;
                    )

        except ValueError as e:
            if &#34;No fem found&#34; in str(e):
                print_i(&#34;Simulation failed. Time to plot results&#34;)
            else:
                raise e</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.per_sensor_plots"><code class="name flex">
<span>def <span class="ident">per_sensor_plots</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>, rows: int = 3, strain_sensors_startwith: str = 'T', strain_sensors_ignore: List[str] = ['T0'], individual_sensors: List[str] = ['T4', 'U3'], plot_diana: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compare the bridge 705 measurement campaign to Diana and OpenSees.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def per_sensor_plots(
    c: Config,
    rows: int = 3,
    strain_sensors_startwith: str = &#34;T&#34;,
    strain_sensors_ignore: List[str] = [&#34;T0&#34;],
    individual_sensors: List[str] = [&#34;T4&#34;, &#34;U3&#34;],
    plot_diana: bool = False,
):
    &#34;&#34;&#34;Compare the bridge 705 measurement campaign to Diana and OpenSees.&#34;&#34;&#34;
    plt.portrait()
    size = 80  # Size of scatter plot points.
    lw = 4  # Line width of plots.

    ##########
    # Strain #
    ##########

    print_i(&#34;All strain sensors = &#34;)
    print_i(f&#34;  {sorted(set(_meas[&#39;sensorlabel&#39;]))}&#34;)
    # All strain measurements for a given sensor set (strain_sensors_startwith),
    # except ignore sensors in ignore set (strain_sensors_ignore).
    tno_strain_meas = _meas.loc[
        _meas[&#34;sensorlabel&#34;].str.startswith(strain_sensors_startwith)
    ]
    labels_before_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    tno_strain_meas = tno_strain_meas.loc[
        ~tno_strain_meas[&#34;sensorlabel&#34;].isin(strain_sensors_ignore)
    ]
    labels_after_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    labels_ignored = sorted(
        l for l in labels_before_ignore if l not in labels_after_ignore
    )
    print_i(f&#34;Strain sensors ignored = {labels_ignored}&#34;)

    # Ignore sensors with missing positions.
    positions_available = set(
        _strain_sensors[_strain_sensors[&#34;direction&#34;] == &#34;X&#34;][&#34;label&#34;]
    )
    labels_before_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    tno_strain_meas = tno_strain_meas.loc[
        tno_strain_meas[&#34;sensorlabel&#34;].isin(positions_available)
    ]
    labels_after_ignore = set(tno_strain_meas[&#34;sensorlabel&#34;])
    labels_ignored = sorted(
        l for l in labels_before_ignore if l not in labels_after_ignore
    )
    print_i(f&#34;Microstrain XXB sensors with missing positions = {labels_ignored}&#34;)

    # Sort by sensor number and setup groupby sensor label.
    tno_strain_meas[&#34;sort&#34;] = tno_strain_meas[&#34;sensorlabel&#34;].apply(lambda x: int(x[1:]))
    print_i(f&#34;Filtered strain sensors starting with {strain_sensors_startwith} =&#34;)
    print_i(f&#34;  {sorted(set(map(int, tno_strain_meas[&#39;sort&#39;])))}&#34;)

    tno_strain_meas = tno_strain_meas.sort_values(by=[&#34;sort&#34;])
    strain_groupby = tno_strain_meas.groupby(&#34;sensorlabel&#34;, sort=False)
    strain_sensor_labels = [sensor_label for sensor_label, _ in strain_groupby]
    strain_sensor_xzs = list(map(_strain_sensor_xz, strain_sensor_labels))
    print(f&#34;strain sensor xsz = {strain_sensor_xzs}&#34;)

    # Find the min and max fem.
    amin, amax = np.inf, -np.inf
    for sensor_label, meas_group in strain_groupby:
        diana_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        responses = (
            diana_group[&#34;infline1&#34;].to_list() + meas_group[&#34;inflinedata&#34;].to_list()
        )
        amin = min(amin, np.amin(responses))
        amax = max(amax, np.amax(responses))
    amin *= 1.1
    amax *= 1.1

    # Calculate displacement with OpenSees via direct simulation.
    print(f&#34;Parallel {c.parallel}&#34;)
    os_strain = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_front_x],
            response_type=ResponseType.StrainXXB,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z)
                for sensor_x, sensor_z in strain_sensor_xzs
            ],
        ).T
        * 1e6
    )
    os_strain_shape = np.array(os_strain).shape
    if len(os_strain_shape) == 3 and os_strain_shape[0] == 1:
        os_strain = os_strain[0]
    amin = min(amin, np.amin(os_strain))
    amax = max(amax, np.amax(os_strain))

    def plot(i, sensor_label, meas_group):
        # Plot Diana predictions for the given sensor.
        if plot_diana:
            diana_sensor_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
            plt.plot(
                diana_sensor_group[&#34;xpostruck&#34;],
                diana_sensor_group[&#34;infline1&#34;],
                lw=lw,
                label=&#34;Diana&#34;,
            )

        # Plot values from OpenSees.
        plt.plot(truck_front_x, os_strain[i], lw=lw, label=&#34;OpenSees&#34;, c=&#34;tab:blue&#34;)

        # Plot measured values against truck position.
        sensor_x, sensor_z = strain_sensor_xzs[i]
        plt.scatter(
            meas_group[&#34;xpostruck&#34;],
            meas_group[&#34;inflinedata&#34;],
            marker=&#34;o&#34;,
            s=size,
            label=&#34;Measurement&#34;,
            zorder=3,
            color=&#34;tab:red&#34;,
        )

        plt.scatter(
            [0],
            [0],
            label=f&#34;{sensor_label}: x = {np.around(sensor_x, 3)} m, z = {np.around(sensor_z, 3)} m&#34;,
            alpha=0,
            zorder=4,
        )
        legend_marker_size(plt.legend(), 80)
        plt.ylabel(&#34;Microstrain XXB&#34;)
        plt.ylim((amin, amax))

    # Create a subplot for each strain sensor.
    plot_i, subplot_i = 0, 0
    for i, (sensor_label, meas_group) in enumerate(strain_groupby):
        plt.subplot(rows, 1, subplot_i + 1)
        plot(i, sensor_label, meas_group)
        if (subplot_i == rows - 1) or i == len(strain_groupby) - 1:
            plt.xlabel(&#34;X position of Truck 1&#39;s front axle (m)&#34;)
            plt.suptitle(
                &#34;Microstrain XXB from Truck 1 on bridge 705\nstatic simulation vs. static test&#34;
            )
            plt.tight_layout(rect=[0, 0.03, 1, 0.93])
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;,
                    f&#34;strain-{strain_sensors_startwith}-{plot_i}.pdf&#34;,
                )
            )
            plt.close()
            subplot_i = 0
            plot_i += 1
        else:
            plt.tick_params(axis=&#34;x&#34;, bottom=False, labelbottom=False)
            subplot_i += 1

    # Create any plots for individual strain sensors.
    for i, (sensor_label, meas_group) in enumerate(strain_groupby):
        if sensor_label in individual_sensors:
            plt.landscape()
            plot(i, sensor_label, meas_group)
            plt.tight_layout()
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;, f&#34;strain-sensor-{sensor_label}.pdf&#34;
                )
            )
            plt.close()
            plt.portrait()

    ################
    # Vert. trans. #
    ################

    # All displacement measurements.
    displa_meas = pd.DataFrame(_meas.loc[_meas[&#34;sensortype&#34;] == &#34;displacements&#34;])

    # Sort by sensor number and setup groupby sensor label.
    displa_meas[&#34;sort&#34;] = displa_meas[&#34;sensorlabel&#34;].apply(lambda x: int(x[1:]))
    displa_meas = displa_meas.sort_values(by=[&#34;sort&#34;])
    displa_groupby = displa_meas.groupby(&#34;sensorlabel&#34;, sort=False)
    displa_sensor_labels = [sensor_label for sensor_label, _ in displa_groupby]
    displa_sensor_xzs = list(map(_displa_sensor_xz, displa_sensor_labels))

    # Find the min and max fem.
    amin, amax = np.inf, -np.inf
    for sensor_label, meas_group in displa_groupby:
        diana_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
        responses = (
            diana_group[&#34;infline1&#34;].to_list() + meas_group[&#34;inflinedata&#34;].to_list()
        )
        amin = min(amin, np.amin(responses))
        amax = max(amax, np.amax(responses))
    amin *= 1.1
    amax *= 1.1

    # Calculate displacement with OpenSees via direct simulation.
    os_displacement = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_front_x],
            response_type=ResponseType.YTrans,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z)
                for sensor_x, sensor_z in displa_sensor_xzs
            ],
        ).T
        * 1000
    )
    amin = min(amin, np.amin(os_displacement))
    amax = max(amax, np.amax(os_displacement))

    def plot(i, sensor_label, meas_group):
        # Plot Diana predictions for the given sensor.
        if plot_diana:
            diana_sensor_group = diana[diana[&#34;sensorlabel&#34;] == sensor_label]
            plt.plot(
                diana_sensor_group[&#34;xpostruck&#34;],
                diana_sensor_group[&#34;infline1&#34;],
                lw=lw,
                label=&#34;Diana&#34;,
            )

        # Plot values from OpenSees.
        plt.plot(
            truck_front_x, os_displacement[i], lw=lw, label=&#34;OpenSees&#34;, c=&#34;tab:blue&#34;
        )
        if i == 0:
            print(os_displacement[i])
            print(f&#34;Truck front (head) = {truck_front_x[:7]}&#34;)
            print(f&#34;Printed os_displacement&#34;)

        # Plot measured values sorted by truck position.
        sensor_x, sensor_z = displa_sensor_xzs[i]
        plt.scatter(
            meas_group[&#34;xpostruck&#34;],
            meas_group[&#34;inflinedata&#34;],
            s=size,
            label=&#34;Measurement&#34;,
            zorder=3,
            color=&#34;tab:red&#34;,
        )

        plt.scatter(
            [0],
            [0],
            label=f&#34;{sensor_label}: x = {np.around(sensor_x, 3)} m, z = {np.around(sensor_z, 3)} m&#34;,
            alpha=0,
        )

        legend_marker_size(plt.legend(), 80)
        plt.ylabel(f&#34;{ResponseType.YTrans.name()} (mm)&#34;)
        plt.ylim((amin, amax))

    # Create a subplot for each displacement sensor.
    plot_i, subplot_i = 0, 0
    for i, (sensor_label, meas_group) in enumerate(displa_groupby):
        plt.subplot(rows, 1, subplot_i + 1)
        plot(i, sensor_label, meas_group)
        if (subplot_i == rows - 1) or i == len(displa_groupby) - 1:
            plt.xlabel(&#34;X position of Truck 1&#39;s front axle (m)&#34;)
            plt.suptitle(
                &#34;Y translation from Truck 1 on bridge 705\nstatic simulation vs. static test&#34;
            )
            plt.tight_layout(rect=[0, 0.03, 1, 0.93])
            plt.savefig(c.get_image_path(&#34;validation/sensors&#34;, f&#34;displa-{plot_i}.pdf&#34;))
            plt.close()
            subplot_i = 0
            plot_i += 1
        else:
            plt.tick_params(axis=&#34;x&#34;, bottom=False, labelbottom=False)
            subplot_i += 1

    # Create any plots for individual sensors.
    plt.landscape()
    for i, (sensor_label, meas_group) in enumerate(displa_groupby):
        if sensor_label in individual_sensors:
            plot(i, sensor_label, meas_group)
            plt.tight_layout()
            plt.savefig(
                c.get_image_path(
                    &#34;validation/sensors&#34;, f&#34;displa-sensor-{sensor_label}.pdf&#34;,
                )
            )
            plt.close()</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.plot_convergence"><code class="name flex">
<span>def <span class="ident">plot_convergence</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot convergence as model size is increased.</p>
<p>Loads files named 'convergence-<em>', generated by 'make_convergence' and
renamed manually by you. Note that the '</em>' indicates the plot label which
will be put in the legend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_convergence(c: Config):
    &#34;&#34;&#34;Plot convergence as model size is increased.

    Loads files named &#39;convergence-*&#39;, generated by &#39;make_convergence&#39; and
    renamed manually by you. Note that the &#39;*&#39; indicates the plot label which
    will be put in the legend.

    &#34;&#34;&#34;
    convergence_dir = os.path.dirname(
        c.get_image_path(&#34;convergence&#34;, &#34;_&#34;, bridge=False)
    )

    # Get all simulations results from each machine.
    machines = dict()
    for filepath in glob.glob(os.path.join(convergence_dir, &#34;convergence-*&#34;)):
        machine_name = os.path.basename(filepath).split(&#34;-&#34;)[1].split(&#34;.&#34;)[0]
        machines[machine_name] = pd.read_csv(filepath).dropna()

    if len(machines) == 0:
        raise ValueError(f&#34;No results found in {convergence_dir}&#34;)

    # Map from machine name to loading position to list of Series.
    machine_results = defaultdict(lambda: defaultdict(list))
    for machine_name, df in machines.items():
        for _, row in df.iterrows():
            x_load, z_load = row[&#34;xload&#34;], row[&#34;zload&#34;]
            machine_results[machine_name][(x_load, z_load)].append(row)

    # Map from machine name to loading position to list of lines to plot.
    results = defaultdict(dict)
    for machine_name, loading_pos_dict in machine_results.items():
        for (x_load, z_load), rows in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = (
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
                [],
            )
            for row in rows:
                max_mesh.append(row[&#34;max_mesh&#34;])
                mins_d.append(row[&#34;min_d&#34;])
                maxes_d.append(row[&#34;max_d&#34;])
                means_d.append(row[&#34;mean_d&#34;])
                mins_s.append(row[&#34;min_s&#34;])
                maxes_s.append(row[&#34;max_s&#34;])
                means_s.append(row[&#34;mean_s&#34;])
                time.append(row[&#34;time&#34;])
                ndeck.append(row[&#34;decknodes&#34;])
                npier.append(row[&#34;piernodes&#34;])
                shell_size.append(row[&#34;shell-size&#34;])
                deck_shell_size.append(row[&#34;deck-size&#34;])
                pier_shell_size.append(row[&#34;pier-size&#34;])
            results[machine_name][(x_load, z_load)] = list(
                map(
                    np.array,
                    [
                        max_mesh,
                        mins_d,
                        maxes_d,
                        means_d,
                        mins_s,
                        maxes_s,
                        means_s,
                        time,
                        ndeck,
                        npier,
                        shell_size,
                        deck_shell_size,
                        pier_shell_size,
                    ],
                )
            )

    def plot_intersection(x, xs, ys, of=None, units=None):
        y = np.interp(x, xs, ys)
        y_frac = y / ys[-1]
        y_percent = y_frac * 100
        label = None
        if of is not None:
            label = f&#34;{y_percent:.2f}% of {of}&#34;
        if units is not None:
            label = f&#34;{units} = {y:.2f}&#34;
        plt.axvline(x, label=label, color=&#34;black&#34;)

    CHOSEN_NUM_NODES = 24500

    ########################################
    ###### Min. and max. per machine #######
    ########################################

    # Displacement
    plt.landscape()
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            num_nodes = ndeck + npier
            final_mean_d = np.mean(means_d[-5:])
            final_max_d = np.mean(maxes_d[-5:])
            final_min_d = np.mean(mins_d[-5:])
            plt.plot(
                num_nodes, mins_d / final_min_d, color=&#34;red&#34;, label=&#34;Min. response&#34;
            )
            plt.plot(
                num_nodes, maxes_d / final_max_d, color=&#34;orange&#34;, label=&#34;Max. response&#34;,
            )
            plt.plot(
                num_nodes, means_d / final_mean_d, color=&#34;green&#34;, label=&#34;Mean response&#34;,
            )
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, mins_d / final_min_d, &#34;min&#34;)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, maxes_d / final_max_d, &#34;max&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, means_d / final_mean_d, &#34;mean&#34;
            )
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Normalized y translation as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Normalized y translation&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;min-max-displa.pdf&#34;, bridge=False))
    plt.close()

    # Strain
    plt.landscape()
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            num_nodes = ndeck + npier
            final_mean_s = np.mean(means_s[-5:])
            final_max_s = np.mean(maxes_s[-5:])
            final_min_s = np.mean(mins_s[-5:])
            plt.plot(
                num_nodes, mins_s / final_min_s, color=&#34;red&#34;, label=&#34;Min. response&#34;
            )
            plt.plot(
                num_nodes, maxes_s / final_max_s, color=&#34;orange&#34;, label=&#34;Max. response&#34;,
            )
            plt.plot(
                num_nodes, means_s / final_mean_s, color=&#34;green&#34;, label=&#34;Mean response&#34;,
            )
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, mins_s / final_min_s, &#34;min&#34;)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, maxes_s / final_max_s, &#34;max&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, means_s / final_mean_s, &#34;mean&#34;
            )

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Normalized strain as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Normalized strain&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;min-max-strain.pdf&#34;, bridge=False))
    plt.close()

    #########################
    ###### Model size #######
    #########################

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = ndeck + npier
            plt.plot(num_nodes, shell_size, label=&#34;Mean shell area&#34;)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, shell_size, units=&#34;Shell area (m²)&#34;
            )
        break

    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Mean shell area as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Shell area (m²)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;model-size.pdf&#34;, bridge=False))
    plt.close()

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            # plt.plot(max_mesh, max_mesh, label=&#34;Max. shell length parameter&#34;)
            plt.plot(max_mesh, shell_size)
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Mean shell area as a function of max. shell length parameter&#34;)
    plt.xlabel(&#34;Max. shell length parameter (m)&#34;)
    plt.ylabel(&#34;Shell area (m²)&#34;)
    # plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;model-size-param.pdf&#34;, bridge=False))
    plt.close()

    # This should be the same for each machine, so skip the rest.
    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = ndeck + npier
            plt.plot(num_nodes, max_mesh)
            plot_intersection(
                CHOSEN_NUM_NODES, num_nodes, max_mesh, units=&#34;Shell length (m)&#34;
            )
        break

    # plt.ylim(plt.ylim()[1], plt.ylim()[0])
    plt.title(&#34;Max. shell length parameter as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Max. shell length parameter (m)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;chosen-param.pdf&#34;, bridge=False))
    plt.close()

    ###################################
    ###### Run time per machine #######
    ###################################

    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines
            num_nodes = (ndeck + npier)[:-1]
            times = time[:-1]
            plt.plot(num_nodes, times)
            plot_intersection(CHOSEN_NUM_NODES, num_nodes, times, units=&#34;Run time (s)&#34;)
            print_w(&#34;Removed one outlier!&#34;)
        break

    # plt.xlim(plt.xlim()[1], plt.xlim()[0])
    plt.title(&#34;Run-time as a function of number of nodes&#34;)
    plt.xlabel(&#34;Number of nodes&#34;)
    plt.ylabel(&#34;Run-time (s)&#34;)
    plt.legend()
    plt.savefig(c.get_image_path(&#34;convergence&#34;, &#34;run-time.pdf&#34;, bridge=False))
    plt.close()

    #########################################
    ###### Individual: min, max, mean #######
    #########################################

    for machine_name, loading_pos_dict in results.items():
        for (x_load, z_load), lines in loading_pos_dict.items():
            (
                max_mesh,
                mins_d,
                maxes_d,
                means_d,
                mins_s,
                maxes_s,
                means_s,
                time,
                ndeck,
                npier,
                shell_size,
                deck_shell_size,
                pier_shell_size,
            ) = lines

            plt.plot(ndeck + npier, maxes_d)
            plt.title(&#34;Maximum displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Maximum displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacement-max-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            plt.plot(ndeck + npier, mins_d)
            plt.title(&#34;Minimum displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Minimum displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacement-min-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            plt.plot(ndeck + npier, means_d)
            plt.title(&#34;Mean displacement as a function of number of nodes&#34;)
            plt.xlabel(&#34;Number of nodes&#34;)
            plt.ylabel(&#34;Mean displacement (mm)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;displacment-mean-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()

            ############################################
            ###### Individual: Mean element size #######
            ############################################

            plt.plot(shell_size, shell_size, label=&#34;Mean shell area&#34;)
            plt.plot(shell_size, deck_shell_size, label=&#34;Mean deck shell area&#34;)
            plt.plot(shell_size, pier_shell_size, label=&#34;Mean pier shell area&#34;)
            # plt.xlim(plt.xlim()[1], plt.xlim()[0])
            # plt.ylim(plt.ylim()[1], plt.ylim()[0])
            plt.legend()
            plt.title(&#34;Mean shell area&#34;)
            plt.xlabel(&#34;Mean shell area (m²)&#34;)
            plt.ylabel(&#34;Mean shell area (m²)&#34;)
            plt.savefig(
                c.get_image_path(
                    &#34;convergence&#34;, f&#34;mean-element-size-{machine_name}.pdf&#34;, bridge=False
                )
            )
            plt.close()</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.plot_nesw_strain_convergence"><code class="name flex">
<span>def <span class="ident">plot_nesw_strain_convergence</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>, filepath: str, from_: str, label: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot convergence of strain at different points around a load.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_nesw_strain_convergence(c: Config, filepath: str, from_: str, label: str):
    &#34;&#34;&#34;Plot convergence of strain at different points around a load.&#34;&#34;&#34;
    headers = [&#34;max_shell_len&#34;, &#34;decknodes&#34;, &#34;piernodes&#34;, &#34;compass&#34;, &#34;fem&#34;]
    parsed_lines = []
    with open(filepath) as f:
        lines = list(map(lambda l: l.split(&#34;,&#34;, len(headers) - 1), f.readlines()[1:]))
    for max_mesh, deck_nodes, pier_nodes, compass, responses in lines:
        parsed_lines.append(
            [
                float(max_mesh),
                float(deck_nodes),
                float(pier_nodes),
                compass.strip(),
                np.array(
                    list(
                        map(
                            float,
                            responses.replace(&#34;[&#34;, &#34;&#34;).replace(&#34;]&#34;, &#34;&#34;).split(&#34;,&#34;),
                        )
                    )
                ),
            ]
        )
    df = pd.DataFrame(parsed_lines, columns=headers)
    # First find the maximum distance traversed.
    delta_distance = 0.05
    max_distance = 0
    for compass in [&#34;N&#34;, &#34;S&#34;, &#34;E&#34;, &#34;W&#34;]:
        compass_df = df[df[&#34;compass&#34;] == compass]
        responses = compass_df.iloc[0][&#34;fem&#34;]
        max_distance = max(len(responses) * delta_distance, max_distance)
    # Overriding maximum distance.
    # max_distance = 4
    # Create color mappable for distances.
    norm = matplotlib.colors.Normalize(vmin=0, vmax=max_distance)
    cmap = cm.get_cmap(&#34;jet&#34;)
    mappable = cm.ScalarMappable(norm=norm, cmap=cmap)
    color = lambda d: mappable.to_rgba(d)
    # For each compass point.
    plt.square()
    fig, axes = plt.subplots(nrows=2, ncols=2)
    for ax, compass, compass_name, in zip(
        axes.flat, [&#34;N&#34;, &#34;S&#34;, &#34;E&#34;, &#34;W&#34;], [&#34;North&#34;, &#34;South&#34;, &#34;East&#34;, &#34;West&#34;]
    ):
        # Collect data into fem per max_shell_len.
        lines = {}
        compass_df = df[df[&#34;compass&#34;] == compass]
        for df_i, row in compass_df.iterrows():
            lines[row[&#34;max_shell_len&#34;]] = row[&#34;fem&#34;]
        # Restructure data into lines for plotting.
        max_shell_lens = []
        sorted_lines = []
        for max_shell_len in sorted(lines.keys()):
            max_shell_lens.append(max_shell_len)
            sorted_lines.append(lines[max_shell_len])
        sorted_lines = np.array(sorted_lines).T
        # Finally plot every nth line.
        distance = 0
        skip = 3
        for responses in sorted_lines[::skip]:
            ax.plot(max_shell_lens, responses, color=color(distance))
            distance += skip * delta_distance
            if distance &gt; max_distance:
                break
        ax.set_xlim(2, min(max_shell_lens))
        ax.set_title(
            f&#34;Strain at increasing distance\nin direction {compass_name} from\n{from_}&#34;
        )
        ax.set_xlabel(&#34;MSL (m)&#34;)
        ax.set_ylabel(&#34;Strain&#34;)
        ax.grid(axis=&#34;y&#34;)
    plt.tight_layout()
    clb = plt.colorbar(mappable, ax=axes.ravel())
    clb.ax.set_title(&#34;Distance (m)&#34;)
    plt.savefig(
        c.get_image_path(&#34;convergence&#34;, f&#34;convergencestrain-{label}.pdf&#34;, bridge=False)
    )
    plt.close()</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.plot_pier_convergence"><code class="name flex">
<span>def <span class="ident">plot_pier_convergence</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>, process: int, pier_i: int, max_nodes: int, strain_ignore_radius: float, nesw_location: int, nesw_max_dist: float, min_shell_len: float, max_shell_len: Union[float, NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot pier convergence, increasing mesh density per simulation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_pier_convergence(
    c: Config,
    process: int,
    pier_i: int,
    max_nodes: int,
    strain_ignore_radius: float,
    nesw_location: int,
    nesw_max_dist: float,
    min_shell_len: float,
    max_shell_len: Optional[float] = None,
):
    &#34;&#34;&#34;Plot pier convergence, increasing mesh density per simulation.&#34;&#34;&#34;
    # We will be modifying the &#39;Config&#39;, so make a copy.
    og_c = c
    c = deepcopy(c)
    sim_params = SimParams(
        response_types=[ResponseType.YTranslation, ResponseType.Strain],
        displacement_ctrl=PierSettlement(displacement=c.pd_unit_disp, pier=pier_i),
    )
    pier = c.bridge.supports[pier_i]
    if nesw_location == 0:
        nesw_point = Point(
            x=pier.x - (pier.length / 2), y=0, z=pier.z + (pier.width_top / 2)
        )
    else:
        raise ValueError(&#34;Invalid NESW plot location&#34;)
    if max_shell_len is None:
        max_shell_len = c.bridge.length / 10
    # Construct a function to ignore fem, this is around pier lines.
    without = without.pier_lines(c=c, radius=strain_ignore_radius)

    def update_bridge():
        c.bridge.name = &#34;Bridge 705&#34;
        c.bridge.accuracy = f&#34;convergence-pier-{pier_i}-{max_shell_len}&#34;
        c.bridge.base_mesh_deck_max_x = max_shell_len
        c.bridge.base_mesh_deck_max_z = max_shell_len
        c.bridge.base_mesh_pier_max_long = max_shell_len
        return c.bridge

    # Write parameter information to the results file.
    filepath = c.get_image_path(
        &#34;convergence-pier&#34;,
        safe_str(f&#34;{c.bridge.name}-{process}-convergence-results-pier-{pier_i}&#34;)
        + &#34;.csv&#34;,
        # We are storing results for all model sizes in the same file, so no
        # need for bridge accuracy in filepath.
        acc=False,
    )
    print_i(f&#34;Expecting parameters at {filepath}&#34;)

    if not os.path.exists(filepath):
        print_i(filepath)
        # Parameters of simulations are written to a file.
        df = pd.DataFrame(
            columns=[
                &#34;deck-nodes&#34;,
                &#34;pier-nodes&#34;,
                &#34;time&#34;,
                &#34;shell-size&#34;,
                &#34;deck-size&#34;,
                &#34;pier-size&#34;,
            ]
        )
        df.index.name = &#34;max-shell-len&#34;
        df.to_csv(filepath)
    df = pd.read_csv(filepath, index_col=&#34;max-shell-len&#34;)

    max_shell_lens = list(np.arange(max_shell_len, 2 - 0.00001, -1))
    max_shell_lens += list(np.arange(1.9, 1 - 0.00001, -0.1))
    max_shell_lens += list(np.arange(0.9, 0.1 - 0.00001, -0.01))
    max_shell_lens = list(map(round_m, max_shell_lens))
    max_shell_lens = [msl for msl in max_shell_lens if msl &lt;= max_shell_len]
    max_shell_lens = [msl for msl in max_shell_lens if msl &gt;= min_shell_len]
    print_i(f&#34;Max shell lens = {max_shell_lens}&#34;)

    # Load fem for each parameter setting. If the simulation has not run
    # yet then it will be run and the parameter settings saved.
    all_displacements = dict()
    all_strains = dict()
    for max_shell_len in max_shell_lens:
        print(f&#34;max shell len = {max_shell_len}&#34;)
        update_bridge()
        try:
            # Start timing and load the results into memory.
            start = timer()
            displacements = load_fem_responses(
                c=c,
                sim_params=sim_params,
                response_type=ResponseType.YTranslation,
                sim_runner=OSRunner(c),
            )
            all_displacements[max_shell_len] = displacements
            strains = load_fem_responses(
                c=c,
                sim_params=sim_params,
                response_type=ResponseType.Strain,
                sim_runner=OSRunner(c),
            )
            all_strains[max_shell_len] = strains.resize()
            end = timer()
            # If the simulation was run, then nodes from the built FEM will be
            # attached. In that case save the paramameters.
            if hasattr(sim_params, &#34;bridge_nodes&#34;):
                nodes = det_nodes(sim_params.bridge_nodes)
                # Clear the parameter, so the test works next iteration.
                del sim_params.bridge_nodes
                deck_nodes = len([n for n in nodes if n.deck])
                pier_nodes = len([n for n in nodes if not n.deck])
                assert deck_nodes + pier_nodes == len(nodes)
                # Determine shell sizes for the deck, pier and whole bridge.
                shells = det_shells(sim_params.bridge_shells)
                avg_shell_size = np.mean([s.area() for s in shells])
                avg_deck_size = np.mean([s.area() for s in shells if not s.pier])
                avg_pier_size = np.mean([s.area() for s in shells if s.pier])
                # Add the new parameters to the DataFrame and write to disk.
                if max_shell_len in df.index:
                    df.drop(max_shell_len)
                df.append(pd.Series(name=max_shell_len))
                for param_name, param in [
                    (&#34;deck-nodes&#34;, deck_nodes),
                    (&#34;pier-nodes&#34;, pier_nodes),
                    (&#34;time&#34;, end - start),
                    (&#34;shell-size&#34;, avg_shell_size),
                    (&#34;deck-size&#34;, avg_deck_size),
                    (&#34;pier-size&#34;, avg_pier_size),
                ]:
                    df.at[max_shell_len, param_name] = param
                df.to_csv(filepath)
            row = df.loc[max_shell_len, :]
            # Stop the simulation if maximum amount of nodes are reached.
            if float(row[&#34;deck-nodes&#34;]) + float(row[&#34;pier-nodes&#34;]) &gt; max_nodes:
                print_i(&#34;Maximum nodes reached&#34;)
                break
            # TODO: Remove to deck interpolation test.
            # for x in displacements.xs:
            #     if 0 in displacements.zs[x]:
            #         for z in displacements.zs[x][0]:
            #             og = displacements.fem[0][x][0][z]
            #             ip = displacements.at_deck(Point(x=x, y=0, z=z), interp=True)
            #             assert np.isclose(og, ip)
        except ValueError as e:
            if &#34;No fem found&#34; in str(e):
                print_i(&#34;Simulation failed. Time to plot results&#34;)
                break
            else:
                raise e

    plot_nesw_convergence(
        c=og_c,
        df=df,
        responses=all_strains,
        point=nesw_point,
        max_distance=nesw_max_dist,
        from_=f&#34;the NW point of pier {pier_i}&#34;,
    )
    filepath = og_c.get_image_path(
        &#34;convergence-pier&#34;,
        safe_str(f&#34;{og_c.bridge.name}-{process}-convergence-nesw-pier-{pier_i}&#34;)
        + &#34;.pdf&#34;,
        acc=False,
    )
    plt.savefig(filepath)
    plt.close()

    # For each set of fem remove the removed points.
    # for key, displacements in all_displacements.items():
    #     all_displacements[key] = displacements.without(without)
    #     print(f&#34;Filtering displacements with max shell len {key}&#34;, end=&#34;\r&#34;)
    # print()

    # Plot convergence of strain, first with all sensors, then without some.
    title = f&#34;Strain convergence as a function of model size\ndue to settlement of pier {pier_i}&#34;
    plot_mmm_strain_convergence(
        c=og_c, pier=pier, df=df, all_strains=all_strains, title=title, append=&#34;0&#34;
    )
    plot_mmm_strain_convergence(
        c=og_c,
        pier=pier,
        df=df,
        all_strains=all_strains,
        title=title,
        without=without,
        append=f&#34;{strain_ignore_radius}&#34;,
    )</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.r2_plots"><code class="name flex">
<span>def <span class="ident">r2_plots</span></span>(<span>c: <a title="bridge_sim.model.Config" href="../../../model/index.html#bridge_sim.model.Config">Config</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>R² plots for displacement and strain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def r2_plots(c: Config):
    &#34;&#34;&#34;R² plots for displacement and strain.&#34;&#34;&#34;
    rt_y = ResponseType.YTrans
    rt_s = ResponseType.StrainXXB

    ################
    # Displacement #
    ################

    # Sensor label, truck x position, and response value.
    displa_meas: List[Tuple[str, float, float]] = []
    displa_diana: List[Tuple[str, float, float]] = []
    # List of sensor labels and positions in the same order as above.
    sensors = []
    # All truck positions used in measurements.
    truck_xs_meas = set()

    # For each sensor and truck x position plot the recorded measurement and
    # Diana response.
    for row in _displa_sensors.itertuples():
        sensor_label = getattr(row, &#34;label&#34;)
        x, z = _displa_sensor_xz(sensor_label)
        sensors.append((sensor_label, x, z))
        responses = _meas[_meas[&#34;sensorlabel&#34;] == sensor_label]
        for sensor_row in responses.itertuples():
            truck_x = getattr(sensor_row, &#34;xpostruck&#34;)
            truck_xs_meas.add(truck_x)
            response = getattr(sensor_row, &#34;inflinedata&#34;)
            displa_meas.append((sensor_label, truck_x, response))
            displa_diana.append(
                diana_response(sensor_label=sensor_label, truck_x=truck_x)
            )
    truck_xs_meas = sorted(truck_xs_meas)

    # Displacement in OpenSees via direct simulation (measurement points).
    displa_os_meas = (
        to_vehicles_direct(
            c=c,
            vehicles=[truck1],
            times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_xs_meas],
            response_type=rt_y,
            points=[
                Point(x=sensor_x, y=0, z=sensor_z) for _, sensor_x, sensor_z in sensors
            ],
        )
        * 1000
    )

    def get_os_meas(sensor_label: str, truck_x: float):
        for i, truck_x_ in enumerate(truck_xs_meas):
            if truck_x_ == truck_x:
                for j, (sensor_label_, _, _) in enumerate(sensors):
                    if sensor_label_ == sensor_label:
                        return displa_os_meas[i][j]
        raise ValueError(
            f&#34;No match. sensor_label = {sensor_label}, truck_x = {truck_x}&#34;
        )

    # Subplot: Diana against measurements.
    plt.portrait()
    plt.subplot(3, 1, 1)
    x = list(map(lambda x: x[2], displa_meas))
    y = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y, color=&#34;tab:blue&#34;)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: Diana vs. measurements&#34;)
    plt.xlabel(f&#34;{rt_y.name()} measurement (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in Diana (mm)&#34;)

    # Subplot: OpenSees against measurements.
    plt.subplot(3, 1, 2)
    x = list(map(lambda x: x[2], displa_meas))
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y, color=&#34;tab:blue&#34;)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: OpenSees vs. measurements&#34;)
    plt.xlabel(f&#34;{rt_y.name()} measurement (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in OpenSees (mm)&#34;)

    # Subplot: OpenSees against Diana.
    plt.subplot(3, 1, 3)
    x = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in displa_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(f&#34;{rt_y.name()}: OpenSees vs. Diana&#34;)
    plt.xlabel(f&#34;{rt_y.name()} in Diana (mm)&#34;)
    plt.ylabel(f&#34;{rt_y.name()} in OpenSees (mm)&#34;)

    plt.tight_layout()
    plt.savefig(c.get_image_path(&#34;validation/regression&#34;, &#34;regression-displa.pdf&#34;))
    plt.close()

    ####################
    ###### Strain ######
    ####################

    # Sensor label, truck x position, and response value.
    strain_meas: List[Tuple[str, float, float]] = []
    strain_diana: List[Tuple[str, float, float]] = []
    # List of sensor labels and positions in the same order as above.
    sensors = []

    # For each sensor and truck x position record measurment and Diana response.
    count_nan = 0
    for row in _strain_sensors.itertuples():
        sensor_label = getattr(row, &#34;label&#34;)
        x, z = _strain_sensor_xz(sensor_label)
        sensors.append((sensor_label, x, z))
        responses = _meas[_meas[&#34;sensorlabel&#34;] == sensor_label]
        for sensor_row in responses.itertuples():
            truck_x = getattr(sensor_row, &#34;xpostruck&#34;)
            response = getattr(sensor_row, &#34;inflinedata&#34;)
            if not np.isnan(response):
                strain_meas.append((sensor_label, truck_x, response))
                strain_diana.append(
                    diana_response(sensor_label=sensor_label, truck_x=truck_x)
                )
            else:
                count_nan += 1

    print_i(f&#34;Count nan = {count_nan}&#34;)

    # Strain in OpenSees via direct simulation (measurement points).
    strain_os_meas = to_vehicles_direct(
        c=c,
        vehicles=[truck1],
        times=[truck1.time_at(x=x, bridge=c.bridge) for x in truck_xs_meas],
        response_type=rt_s,
        points=[
            Point(x=sensor_x, y=0, z=sensor_z) for _, sensor_x, sensor_z in sensors
        ],
    )

    def get_os_meas(sensor_label: str, truck_x: float):
        for i, truck_x_ in enumerate(truck_xs_meas):
            if truck_x_ == truck_x:
                for j, (sensor_label_, _, _) in enumerate(sensors):
                    if sensor_label_ == sensor_label:
                        return strain_os_meas[i][j]
        raise ValueError(
            f&#34;No match. sensor_label = {sensor_label}, truck_x = {truck_x}&#34;
        )

    # Subplot: Diana against measurements.
    plt.subplot(3, 1, 1)
    x = list(map(lambda x: x[2], strain_meas))
    y = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain XXB: Diana vs. measurements&#34;)
    plt.xlabel(&#34;Microstrain XXB measurement&#34;)
    plt.ylabel(&#34;Microstrain XXB in Diana&#34;)

    # Subplot: OpenSees against measurements.
    plt.subplot(3, 1, 2)
    x = list(map(lambda x: x[2], strain_meas))
    y = np.array(
        [
            get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
            for sensor_label, truck_x, _ in strain_meas
        ]
    )
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain XXB: OpenSees vs. measurements&#34;)
    plt.xlabel(&#34;Microstrain XXB measurement&#34;)
    plt.ylabel(&#34;Microstrain XXB in OpenSees&#34;)

    # Subplot: OpenSees against Diana.
    plt.subplot(3, 1, 3)
    x = [
        diana_response(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    y = [
        get_os_meas(sensor_label=sensor_label, truck_x=truck_x)
        for sensor_label, truck_x, _ in strain_meas
    ]
    plt.scatter(x, y)
    regressor = LinearRegression().fit(np.matrix(x).T, y)
    y_pred = regressor.predict(np.matrix(x).T)
    score = regressor.score(np.matrix(x).T, y)
    plt.plot(x, y_pred, color=&#34;tab:red&#34;, label=f&#34;R² = {score:.3f}&#34;)
    plt.legend()
    plt.title(&#34;Strain: OpenSees vs. Diana&#34;)
    plt.xlabel(&#34;Microstrain XXB in Diana&#34;)
    plt.ylabel(&#34;Microstrain XXB in OpenSees&#34;)

    plt.tight_layout()
    plt.savefig(c.get_image_path(&#34;validation/regression&#34;, &#34;regression-strain.pdf&#34;))</code></pre>
</details>
</dd>
<dt id="bridge_sim.internal.make.plot.verification.temp_plots"><code class="name flex">
<span>def <span class="ident">temp_plots</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def temp_plots():
    sensors = [&#34;TA&#34;, &#34;TB&#34;, &#34;TC&#34;, &#34;U13&#34;, &#34;U26&#34;, &#34;U29&#34;]
    data_path = &#34;validation/sensors&#34;
    times, temps, responses = [], [], [[] for _ in sensors]
    for i in range(1, 13 + 1):
        # Times.
        times_path = os.path.join(data_path, f&#34;times{i}.csv&#34;)
        with open(times_path) as f:
            lines = f.read().split(&#34;,&#34;)
        parse_time = lambda l: datetime.strptime(l.split()[1], &#34;%H:%M:%S&#34;)
        times.append(list(map(parse_time, lines)))
        # Temps.
        temps_path = os.path.join(data_path, f&#34;temps{i}.csv&#34;)
        with open(temps_path) as f:
            lines = f.read().split(&#34;,&#34;)
        temps.append(list(map(float, lines)))
        assert len(times[-1]) == len(temps[-1])
        # Sensors.
        for s_i, sensor in enumerate(sensors):
            sensor_path = os.path.join(data_path, f&#34;{sensor}{i}.csv&#34;)
            with open(sensor_path) as f:
                lines = f.read().split(&#34;,&#34;)
            sensor_responses = list(map(float, lines))
            responses[s_i].append(sensor_responses)
            assert len(responses[s_i][-1]) == len(temps[-1])
    # Plot times versus temperatures.
    all_times = np.concatenate(times)
    all_temps = np.concatenate(temps)
    assert len(all_times) == len(all_temps)
    plt.scatter(all_times, all_temps)
    plt.title(&#34;Time versus temperature&#34;)
    plt.show()
    for s_i, sensor in enumerate(sensors):
        # sensor_responses = np.concatenate(fem[s_i])
        sensor_responses = [responses[s_i][i][0] for i in range(13)]
        plot_temps = [temps[i][0] for i in range(13)]
        # assert len(sensor_responses) == len(all_times)
        plt.scatter(plot_temps, sensor_responses)
        plt.show()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bridge_sim.internal.make.plot" href="index.html">bridge_sim.internal.make.plot</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bridge_sim.internal.make.plot.verification.axis_comparison" href="#bridge_sim.internal.make.plot.verification.axis_comparison">axis_comparison</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.diana_response" href="#bridge_sim.internal.make.plot.verification.diana_response">diana_response</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.make_convergence_data" href="#bridge_sim.internal.make.plot.verification.make_convergence_data">make_convergence_data</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.per_sensor_plots" href="#bridge_sim.internal.make.plot.verification.per_sensor_plots">per_sensor_plots</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.plot_convergence" href="#bridge_sim.internal.make.plot.verification.plot_convergence">plot_convergence</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.plot_nesw_strain_convergence" href="#bridge_sim.internal.make.plot.verification.plot_nesw_strain_convergence">plot_nesw_strain_convergence</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.plot_pier_convergence" href="#bridge_sim.internal.make.plot.verification.plot_pier_convergence">plot_pier_convergence</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.r2_plots" href="#bridge_sim.internal.make.plot.verification.r2_plots">r2_plots</a></code></li>
<li><code><a title="bridge_sim.internal.make.plot.verification.temp_plots" href="#bridge_sim.internal.make.plot.verification.temp_plots">temp_plots</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>